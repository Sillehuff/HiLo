<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Hilo Playlist ‚Äì Instructor Edition</title>
  <meta name="description" content="Professional class planning with playlist optimization and cloud sync" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'><circle cx='24' cy='24' r='22' stroke='%23c9a15d' stroke-width='2' fill='none'/><path d='M14 30C16 20 20 16 24 16C28 16 32 20 34 30' stroke='%23c9a15d' stroke-width='3' stroke-linecap='round'/><path d='M12 36H36' stroke='%23c9a15d' stroke-width='2' stroke-linecap='round'/></svg>" />
  <meta name="theme-color" content="#0d1512" />
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png" />

  <style>
    :root {
      --primary: #243b33;
      --accent: #c9a15d;
      --cream: #f6f4f0;
      --ink: #0f0f0f;
      --ink-light: #2b2b2b;
      --glass: rgba(255,255,255,0.08);
      --radius: 16px;
      --radius-lg: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,.22), 0 4px 12px rgba(0,0,0,.18);
      --inner-shadow: inset 0 1px 0 rgba(255,255,255,.08), inset 0 -1px 0 rgba(0,0,0,.15);
      --blur: blur(16px);
      --gap: 18px;
      --success: #2ecc71;
      --warning: #f39c12;
      --danger: #e74c3c;
      --info: #3498db;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }
    /* Apple-like base */
    html, body {
      margin: 0;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      background-color: #0d1512;
      background: linear-gradient(180deg, #0d1512 0%, #16231d 40%, #1b2d25 100%);
      color: var(--cream);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Inter", "Helvetica Neue", Arial, system-ui, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-text-size-adjust: 100%;
      min-height: 100vh;
      min-height: 100dvh;
    }
    * { box-sizing: border-box; }
    a { color: inherit; text-decoration: none; }
    .nav {
      position: sticky; top: 0; z-index: 20;
      display: flex; align-items: center; justify-content: space-between;
      padding: 14px clamp(14px, 3vw, 28px) 14px;
      min-height: 58px;
      background: rgba(20, 34, 28, .92);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(255,255,255,.06);
    }
    .brand {
      display:flex; align-items:center; gap:10px;
      font-weight: 700; letter-spacing:.2px;
    }
    .brand svg { width: 28px; height: 28px; }
    .tabs {
      display: flex; gap: 8px; flex-wrap: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .tabs::-webkit-scrollbar { display: none; }
    .tab-btn {
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(255,255,255, .06);
      border: 1px solid rgba(255,255,255,.08);
      color: #f7f7f7;
      cursor: pointer;
      transition: all .15s ease;
      font-size: 14px;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }
    .tab-btn .tab-icon { font-size: 15px; line-height: 1; }
    .tab-btn .tab-label { white-space: nowrap; }
    .tab-btn[aria-selected="true"] {
      background: linear-gradient(180deg, rgba(201,161,93,.28), rgba(201,161,93,.14));
      border-color: rgba(201,161,93,.55);
      box-shadow: 0 6px 18px rgba(201,161,93,.26);
    }
    .tab-btn:hover {
      background: rgba(255,255,255, .1);
      transform: translateY(-1px);
    }
    .tab-btn:active { transform: scale(.98); }
    .container {
      max-width: 1200px;
      margin: 24px auto;
      padding: 0 clamp(12px, 3vw, 24px);
      display: grid;
      gap: var(--gap);
    }
    /* Hero */
    .hero {
      position: relative;
      border-radius: var(--radius-lg);
      padding: clamp(18px, 3vw, 28px);
      background: radial-gradient(1200px 600px at 0% -10%, rgba(201,161,93,.12), transparent 60%),
                  radial-gradient(800px 500px at 100% 110%, rgba(201,161,93,.08), transparent 60%),
                  rgba(28, 45, 38, .6);
      backdrop-filter: var(--blur);
      border: 1px solid rgba(255,255,255,.07);
      box-shadow: var(--shadow);
    }
    .hero h1 {
      margin: 0 0 6px 0;
      font-size: clamp(22px, 3vw, 32px);
      font-weight: 800;
      letter-spacing: .2px;
    }
    .subtle { color: rgba(255,255,255,.8); font-weight: 500; font-size: 15px; }
    .hero .row {
      display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin-top: 10px;
    }
    .pill {
      display:inline-flex; align-items:center; gap:8px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.1);
      padding: 8px 12px; border-radius:999px;
      font-size: 13px;
      transition: all .2s ease;
    }
    .pill:hover {
      transform: translateY(-1px);
    }
    /* Class-type tags */
    .class-type-tag {
      display: inline-flex; align-items: center; gap: 4px;
      background: rgba(52, 152, 219, .18);
      border: 1px solid rgba(52, 152, 219, .35);
      color: rgba(255,255,255,.9);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 500;
    }
    .class-type-tag.compact {
      padding: 2px 7px;
      font-size: 11px;
    }
    .playlist-tags-inline {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-left: 6px;
      vertical-align: middle;
    }
    .tag-editor-row td {
      background: rgba(0,0,0,.25) !important;
      padding: 12px 20px !important;
    }
    .tag-editor {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .tag-editor-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      min-height: 28px;
    }
    .tag-chip-removable {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(52, 152, 219, .22);
      border: 1px solid rgba(52, 152, 219, .4);
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 13px;
      animation: fadeIn .2s ease;
    }
    .remove-tag {
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
      font-size: 12px;
    }
    .remove-tag:hover { opacity: 1; }
    .tag-input-wrapper {
      position: relative;
    }
    .tag-input-wrapper input {
      width: 200px;
      padding: 7px 10px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px;
      color: #fff;
      font-size: 13px;
    }
    .tag-input-wrapper input:focus {
      outline: none;
      border-color: var(--info);
      box-shadow: 0 0 0 3px rgba(52,152,219,.2);
    }
    .tag-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      width: 200px;
      max-height: 160px;
      overflow-y: auto;
      background: rgba(20, 34, 28, .97);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 8px;
      margin-top: 4px;
      z-index: 50;
      box-shadow: 0 8px 24px rgba(0,0,0,.4);
    }
    .tag-autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 13px;
      color: rgba(255,255,255,.85);
      transition: background .15s;
    }
    .tag-autocomplete-item:hover,
    .tag-autocomplete-item.active {
      background: rgba(52, 152, 219, .2);
      color: #fff;
    }
    .explorer-row { cursor: pointer; transition: background .15s; }
    .explorer-row:hover { background: rgba(255,255,255,.08) !important; }
    .explorer-row.retired-row { opacity: .55; }
    /* Add Playlist form */
    .add-playlist-form {
      margin-bottom: 0;
    }
    .add-playlist-form .input-field {
      padding: 8px 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
    }
    .add-playlist-form .input-field:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(201,161,93,.2);
    }
    /* Status pill toggle */
    .status-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid;
      transition: all .2s ease;
      user-select: none;
    }
    .status-toggle.active {
      background: rgba(46, 204, 113, .18);
      border-color: rgba(46, 204, 113, .45);
      color: #2ecc71;
    }
    .status-toggle.retired {
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.15);
      color: rgba(255,255,255,.5);
    }
    .status-toggle:hover {
      transform: scale(1.05);
    }
    /* Remove playlist button */
    .btn-remove-playlist {
      background: rgba(231, 76, 60, .12);
      border: 1px solid rgba(231, 76, 60, .3);
      color: rgba(231, 76, 60, .85);
      border-radius: 8px;
      padding: 5px 10px;
      font-size: 12px;
      cursor: pointer;
      transition: all .2s ease;
    }
    .btn-remove-playlist:hover {
      background: rgba(231, 76, 60, .25);
      border-color: rgba(231, 76, 60, .5);
      color: #e74c3c;
    }
    /* Ghost button */
    .btn-ghost {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.7);
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      transition: all .15s ease;
    }
    .btn-ghost:hover {
      background: rgba(255,255,255,.12);
      color: #fff;
    }
    /* Tags cell in manager table */
    .manager-tags-cell {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
    }
    .manager-tags-cell .add-tag-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px dashed rgba(255,255,255,.2);
      color: rgba(255,255,255,.5);
      cursor: pointer;
      font-size: 14px;
      transition: all .15s ease;
    }
    .manager-tags-cell .add-tag-btn:hover {
      background: rgba(52, 152, 219, .2);
      border-color: rgba(52, 152, 219, .4);
      color: #fff;
    }
    /* Status indicators */
    .status-connected { background: rgba(46, 204, 113, .18); border-color: rgba(46, 204, 113, .45); }
    .status-disconnected { background: rgba(231, 76, 60, .18); border-color: rgba(231, 76, 60, .45); }
    .status-draft { background: rgba(241, 196, 15, .18); border-color: rgba(241, 196, 15, .45); }
    .status-finalized { background: rgba(46, 204, 113, .18); border-color: rgba(46, 204, 113, .45); }
    .status-info { background: rgba(52, 152, 219, .18); border-color: rgba(52, 152, 219, .45); }
    /* Glass cards */
    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--gap);
    }
    .card {
      position: relative;
      border-radius: var(--radius);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.09);
      box-shadow: var(--shadow);
      overflow:hidden;
      transition: all .3s ease;
    }
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 36px rgba(0,0,0,.26), 0 6px 16px rgba(0,0,0,.22);
    }
    .card .body { padding: 16px; }
    .card .title { font-weight: 700; letter-spacing:.2px; margin-bottom: 4px; }
    .card .muted { color: rgba(255,255,255,.8); font-size: 14px; }
    .primary-card {
      background: linear-gradient(180deg, rgba(36,59,51,.82), rgba(36,59,51,.68));
      border-color: rgba(201,161,93,.55);
      border-width: 2px;
    }
    .primary-card .title { color: #fff; font-size: 18px; font-weight: 800; }
    .metric-row {
      display:grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 12px;
    }
    .metric {
      background: rgba(0,0,0,.15);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      padding: 12px;
      text-align:center;
    }
    .metric .value { font-weight: 800; font-size: 26px; color: var(--accent); }
    .metric .label { color: rgba(255,255,255,.8); font-size: 12px; margin-top: 4px; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; justify-content: center; gap: 4px; }
    /* Tooltips */
    .info-tip {
      position: relative;
      cursor: help;
      opacity: 0.5;
      font-size: 12px;
      font-style: normal;
      transition: opacity .2s;
    }
    .info-tip:hover, .info-tip:focus { opacity: 1; }
    .info-tip .tip-text {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(13, 21, 18, .97);
      border: 1px solid rgba(201,161,93,.4);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 400;
      text-transform: none;
      letter-spacing: 0;
      white-space: normal;
      width: 200px;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity .2s ease;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
      color: var(--cream);
    }
    .info-tip .tip-text::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(201,161,93,.4);
    }
    .info-tip:hover .tip-text, .info-tip:focus .tip-text { opacity: 1; }
    .tooltip-wrapper {
      position: relative;
      display: inline-block;
    }
    .tooltip-wrapper .tooltip-text {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(13, 21, 18, .97);
      border: 1px solid rgba(201,161,93,.4);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity .2s ease;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
      color: var(--cream);
    }
    .tooltip-wrapper .tooltip-text::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(201,161,93,.4);
    }
    .tooltip-wrapper:hover .tooltip-text { opacity: 1; }
    .btn:disabled { cursor: not-allowed; }
    .btn { 
      padding: 10px 16px;
      border-radius: 12px;
      background: rgba(255,255,255,.1);
      border:1px solid rgba(255,255,255,.2);
      color: #fff; cursor:pointer;
      transition: all .15s ease;
      font-weight: 600;
      font-size: 14px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .btn:hover {
      background: linear-gradient(180deg, rgba(201,161,93,.3), rgba(201,161,93,.15));
      box-shadow: 0 8px 22px rgba(201,161,93,.25);
      transform: translateY(-1px);
    }
    .btn,
    .tab-btn,
    .btn-xs,
    .status-toggle,
    .btn-remove-playlist,
    .search-clear,
    .modal__close,
    .manager-tags-cell .add-tag-btn {
      touch-action: manipulation;
    }
    .btn:active { transform: translateY(1px) scale(.99); }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .btn:disabled:hover {
      transform: none;
      box-shadow: none;
    }
    .btn-primary {
      background: linear-gradient(180deg, var(--accent), rgba(201,161,93,.8));
      border-color: var(--accent);
    }
    .btn-success {
      background: linear-gradient(180deg, var(--success), rgba(46, 204, 113, .8));
      border-color: var(--success);
    }
    .btn-warning {
      background: linear-gradient(180deg, var(--warning), rgba(243, 156, 18, .8));
      border-color: var(--warning);
    }
    .btn-danger {
      background: linear-gradient(180deg, var(--danger), rgba(231, 76, 60, .8));
      border-color: var(--danger);
    }
    .btn-info {
      background: linear-gradient(180deg, var(--info), rgba(52, 152, 219, .8));
      border-color: var(--info);
    }
    .suggestions { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: var(--gap); }
    .recommender-explain {
      margin-top: 10px;
      font-size: 13px;
      color: rgba(255,255,255,.72);
    }
    .best-strength-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .rec-strength-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .2px;
    }
    .rec-strength-pill.strong {
      background: rgba(46, 204, 113, .18);
      border: 1px solid rgba(46, 204, 113, .45);
      color: #91efbe;
    }
    .rec-strength-pill.moderate {
      background: rgba(241, 196, 15, .18);
      border: 1px solid rgba(241, 196, 15, .45);
      color: #f8da7a;
    }
    .rec-strength-pill.close {
      background: rgba(52, 152, 219, .2);
      border: 1px solid rgba(52, 152, 219, .45);
      color: #9fd0f5;
    }
    .best-summary-title {
      font-size: 22px;
      font-weight: 800;
      line-height: 1.2;
      margin-top: 8px;
    }
    .best-summary-meta {
      margin-top: 6px;
      color: rgba(255,255,255,.72);
      font-size: 13px;
    }
    .best-insight-list {
      margin-top: 10px;
      display: grid;
      gap: 8px;
    }
    .best-insight {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: rgba(255,255,255,.9);
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 10px;
      padding: 8px 10px;
    }
    .best-insight b {
      color: var(--accent);
      min-width: 38px;
      text-align: right;
      font-size: 14px;
    }
    .suggestion-card {
      padding: 14px;
      transition: all .2s ease;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.04);
    }
    .suggestion-card:hover {
      background: rgba(255,255,255,.08);
      transform: translateY(-2px);
      border-color: rgba(201,161,93,.35);
    }
    .runner-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .runner-score-delta {
      font-size: 12px;
      color: rgba(255,255,255,.72);
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      white-space: nowrap;
    }
    .runner-meta {
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255,255,255,.7);
    }
    .runner-actions {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .rec-empty-action {
      margin-top: 10px;
    }
    .rank-row-assigned td {
      background: rgba(46, 204, 113, .12);
    }
    .rank-score {
      font-weight: 700;
      color: var(--accent);
    }
    .dashboard-rankings-wrap {
      overflow-x: auto;
    }
    .class-picker-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: background .15s ease;
      font-size: 13px;
    }
    .class-picker-item:hover {
      background: rgba(255,255,255,.08);
    }
    .class-picker-item input[type="checkbox"] {
      accent-color: var(--accent);
      width: 18px;
      height: 18px;
      cursor: pointer;
      flex-shrink: 0;
    }
    .class-picker-item.checked {
      background: rgba(201,161,93,.12);
    }
    .class-picker-item .class-picker-label {
      flex: 1;
      line-height: 1.4;
    }
    .class-picker-item .class-picker-status {
      font-size: 11px;
      opacity: 0.6;
    }
    /* Date/Time Selection */
    .datetime-selector {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      background: rgba(0,0,0,.1);
      border-radius: var(--radius);
      padding: 16px;
      border: 1px solid rgba(255,255,255,.08);
      margin: 16px 0;
    }
    .datetime-selector label {
      font-weight: 500;
      color: rgba(255,255,255,.9);
      font-size: 14px;
    }
    .datetime-selector input {
      padding: 8px 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
    }
    .datetime-selector input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(201,161,93,.2);
    }
    /* Guest Selection UI */
    .guest-selector {
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: rgba(0,0,0,.1);
      border-radius: var(--radius);
      padding: 16px;
      border: 1px solid rgba(255,255,255,.08);
    }
    .selected-guests-container {
      min-height: 50px;
      max-height: 150px;
      overflow-y: auto;
      padding: 10px;
      background: rgba(0,0,0,.15);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.08);
    }
    .selected-guests {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .no-selection {
      color: rgba(255,255,255,.5);
      font-style: italic;
      padding: 8px 4px;
    }
    .selected-guest-item {
      display: flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(180deg, rgba(201,161,93,.28), rgba(201,161,93,.14));
      border: 1px solid rgba(201,161,93,.35);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 14px;
      animation: fadeIn .2s ease;
    }
    .remove-guest {
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .remove-guest:hover {
      opacity: 1;
    }
    .guest-list-container {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(0,0,0,.15);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.08);
    }
    .guest-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
      padding: 12px;
    }
    .guest-list-item {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 10px 14px;
      min-height: 44px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
      display: flex;
      align-items: center;
    }
    .guest-list-item:hover {
      background: rgba(255,255,255,.1);
      border-color: rgba(201,161,93,.4);
      transform: translateY(-1px);
    }
    .guest-list-item.selected {
      background: linear-gradient(180deg, rgba(201,161,93,.28), rgba(201,161,93,.14));
      border-color: rgba(201,161,93,.55);
      font-weight: 500;
    }
    /* Search Container */
    .search-container {
      position: relative;
      max-width: 300px;
    }
    
    .search-container input {
      width: 100%;
      padding: 12px 40px 12px 40px;
      border-radius: 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      color: #fff;
      font-size: 14px;
    }
    .search-container::before {
      content: 'üîç';
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0.6;
      pointer-events: none;
    }
    .search-container.no-icon::before {
      content: none;
    }
    .search-container.no-icon input {
      padding-left: 14px;
    }
    .search-clear {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255,255,255,.12);
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: rgba(255,255,255,.7);
      font-size: 13px;
      line-height: 1;
      transition: all .15s ease;
      padding: 0;
    }
    .search-clear:hover { background: rgba(255,255,255,.25); color: #fff; }
    .search-clear.visible { display: flex; }
    .search-result-count {
      font-size: 12px;
      color: rgba(255,255,255,.5);
      margin-top: 4px;
      min-height: 16px;
    }
    .search-wrap { display:flex; gap:8px; flex-wrap:wrap; }
    .search { 
      flex:1;
      min-width: 240px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      padding: 10px 12px; border-radius: 12px; color:#fff;
    }
    .select { 
      min-width: 160px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      padding: 10px 12px; border-radius: 12px; color:#fff;
      cursor: pointer;
    }
    /* Enhanced Tables */
    .table-container {
      border-radius: var(--radius);
      overflow: hidden;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
    }
    
    .data-table { 
      width:100%; 
      border-collapse: collapse; 
      background: transparent;
    }
    
    .data-table th, .data-table td { 
      text-align:left; 
      padding: 16px 20px; 
      border-bottom: 1px solid rgba(255,255,255,.08); 
    }
    
    .data-table th { 
      color: rgba(255,255,255,.9); 
      font-weight: 600; 
      background: rgba(255,255,255,.06);
      font-size: 14px;
      letter-spacing: 0.5px;
    }
    
    .data-table tbody tr:hover { 
      background: rgba(255,255,255,.06);
      transition: background 0.2s ease;
    }
    
    .data-table tbody tr:last-child td {
      border-bottom: none;
    }
    .sortable {
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    
    .sortable:hover {
      color: var(--accent);
    }
    
    .sortable::after {
      content: '‚Üï';
      position: absolute;
      right: 8px;
      opacity: 0.5;
      font-size: 12px;
    }
    .sortable.asc::after {
      content: '‚Üë';
      opacity: 1;
    }
    .sortable.desc::after {
      content: '‚Üì';
      opacity: 1;
    }
    /* Section Header */
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 16px;
    }
    
    .section-header h2 {
      margin: 0;
      font-size: 24px;
      font-weight: 700;
      color: #fff;
    }
    /* Weekly Calendar */
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 16px;
      margin-top: 20px;
    }
    .day-card {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.09);
      border-radius: var(--radius);
      padding: 16px;
      min-height: 200px;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
    }
    .day-card:hover {
      background: rgba(255,255,255,.1);
      transform: translateY(-2px);
    }
    .day-card.today {
      border-color: rgba(52, 152, 219, .5);
      box-shadow: 0 0 0 1px rgba(52, 152, 219, .2), var(--shadow);
    }
    .day-card.has-classes {
      border-color: rgba(201,161,93,.4);
      background: rgba(201,161,93,.08);
    }
    .day-card.today.has-classes {
      border-color: rgba(201,161,93,.5);
    }
    .day-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,.1);
    }
    .day-name {
      font-weight: 600;
      color: #fff;
    }
    .day-date {
      font-size: 12px;
      color: rgba(255,255,255,.7);
    }
    .class-list {
      flex-grow: 1;
    }
    .class-item {
      background: rgba(0,0,0,.2);
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 8px;
      font-size: 13px;
      cursor: pointer;
      transition: all .2s ease;
    }
    .class-item:hover {
      background: rgba(0,0,0,.3);
      transform: translateX(2px);
    }
    .class-time {
      font-weight: 600;
      color: var(--accent);
    }
    .class-info {
      color: rgba(255,255,255,.8);
      font-size: 12px;
      margin-top: 2px;
    }
    .class-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    .btn-sm {
      padding: 8px 12px;
      font-size: 13px;
      min-height: 36px;
    }
    /* Guest Grid */
    .guests-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 16px;
    }
    .guest-card {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.09);
      border-radius: var(--radius);
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .guest-card:hover {
      background: rgba(255,255,255,.1);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,.3);
    }
    .guest-card-header {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }
    .guest-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), rgba(201,161,93,.6));
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 18px;
      color: #fff;
    }
    .guest-info h4 {
      margin: 0 0 4px 0;
      font-size: 16px;
      color: #fff;
    }
    .guest-info p {
      margin: 0;
      font-size: 13px;
      color: rgba(255,255,255,.7);
    }
    .guest-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    .guest-stat {
      text-align: center;
      padding: 8px;
      background: rgba(0,0,0,.15);
      border-radius: 8px;
    }
    .guest-stat .value {
      display: block;
      font-size: 20px;
      font-weight: 700;
      color: var(--accent);
    }
    .guest-stat .label {
      display: block;
      font-size: 11px;
      color: rgba(255,255,255,.6);
      margin-top: 2px;
    }
    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,.85);
      backdrop-filter: blur(8px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      animation: fadeIn .2s ease;
    }
    
    .modal__content {
      background: rgba(28, 45, 38, .95);
      backdrop-filter: var(--blur);
      border: 1px solid rgba(255,255,255,.1);
      border-radius: var(--radius-lg);
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow);
      animation: slideUp .3s ease;
    }
    
    .modal__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      flex-shrink: 0;
    }
    
    .modal__header h3 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      color: #fff;
    }
    
    .modal__close {
      background: none;
      border: none;
      font-size: 24px;
      color: rgba(255,255,255,.7);
      cursor: pointer;
      padding: 0;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      transition: all 0.2s ease;
    }
    
    .modal__close:hover {
      background: rgba(255,255,255,.1);
      color: #fff;
    }
    
    .modal__body {
      padding: 24px;
      overflow-y: auto;
    }
     .modal__footer {
      padding: 16px 24px;
      border-top: 1px solid rgba(255,255,255,.08);
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-shrink: 0;
    }
    /* Modal Recommendation Panel */
    .modal-recommendation {
      background: rgba(36,59,51,.5);
      border: 1px solid rgba(201,161,93,.35);
      border-radius: var(--radius);
      padding: 16px;
      margin-bottom: 16px;
    }
    .modal-rec-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .modal-rec-title {
      font-weight: 600;
      font-size: 13px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .modal-rec-best {
      margin-bottom: 10px;
    }
    .modal-rec-best-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-rec-best-name {
      font-size: 18px;
      font-weight: 700;
      color: var(--cream);
    }
    .modal-rec-best-name .accent { color: var(--accent); }
    .modal-rec-metrics {
      display: flex;
      gap: 16px;
      margin-top: 8px;
    }
    .modal-rec-metric {
      text-align: center;
    }
    .modal-rec-metric .val {
      font-size: 16px;
      font-weight: 700;
      color: var(--cream);
    }
    .modal-rec-metric .lbl {
      font-size: 11px;
      color: rgba(255,255,255,.6);
      margin-top: 2px;
    }
    .modal-rec-strength {
      margin-top: 10px;
      font-size: 12px;
      color: rgba(255,255,255,.8);
    }
    .modal-rec-strength strong {
      color: var(--accent);
      margin-right: 4px;
    }
    .modal-rec-alternatives {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .modal-rec-alternatives .alt-label {
      font-size: 12px;
      color: rgba(255,255,255,.6);
      margin-right: 4px;
    }
    .modal-rec-alt-pill {
      padding: 6px 14px;
      min-height: 36px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 999px;
      color: var(--cream);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all .15s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .modal-rec-alt-pill .meta {
      opacity: .75;
      font-size: 11px;
      font-weight: 500;
    }
    .modal-rec-alt-pill:hover {
      background: rgba(201,161,93,.2);
      border-color: rgba(201,161,93,.5);
      transform: translateY(-1px);
    }
    .modal-rec-use-btn {
      padding: 6px 16px;
      min-height: 36px;
      background: linear-gradient(180deg, rgba(201,161,93,.35), rgba(201,161,93,.2));
      border: 1px solid rgba(201,161,93,.5);
      border-radius: 8px;
      color: var(--cream);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all .15s ease;
    }
    .modal-rec-use-btn:hover {
      background: linear-gradient(180deg, rgba(201,161,93,.5), rgba(201,161,93,.3));
      transform: translateY(-1px);
    }
    /* Form styling */
    .form-group {
      margin-bottom: 16px;
    }
    .form-group label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      color: rgba(255,255,255,.9);
      font-size: 14px;
    }
    .form-group input, .form-group select, .form-group textarea {
      width: 100%;
      padding: 10px 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
    }
    .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(201,161,93,.2);
    }
    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    /* Connection status */
    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    .connection-status.connected {
      background: rgba(46, 204, 113, .1);
      border: 1px solid rgba(46, 204, 113, .3);
    }
    .connection-status.disconnected {
      background: rgba(231, 76, 60, .1);
      border: 1px solid rgba(231, 76, 60, .3);
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    .status-dot.connected { background: var(--success); }
    .status-dot.disconnected { background: var(--danger); }
    /* Empty States */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: rgba(255,255,255,.6);
    }

    .empty-state h3 {
      margin: 0 0 8px 0;
      font-size: 18px;
      color: rgba(255,255,255,.8);
    }
    /* Step labels for dashboard workflow */
    .step-label {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: rgba(201,161,93,.85);
    }
    .step-label .step-num {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgba(201,161,93,.2);
      border: 1px solid rgba(201,161,93,.4);
      font-size: 12px;
      font-weight: 700;
      color: var(--accent);
    }
    /* Guest selector header row */
    .guest-selector-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .guest-selector-actions {
      display: flex;
      gap: 6px;
    }
    .btn-xs {
      padding: 8px 12px;
      min-height: 44px;
      font-size: 13px;
      border-radius: 8px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.8);
      cursor: pointer;
      transition: all .15s ease;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .btn-xs:hover {
      background: rgba(255,255,255,.15);
      color: #fff;
    }
    /* Summary stats bar */
    .stats-bar {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      padding: 12px 16px;
      background: rgba(0,0,0,.12);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.06);
      margin-bottom: 16px;
    }
    .stats-bar .stat-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      color: rgba(255,255,255,.8);
    }
    .stats-bar .stat-value {
      font-weight: 700;
      color: var(--accent);
    }
    /* Toast notifications */
    #toast-container {
      position: fixed;
      bottom: calc(24px + var(--safe-bottom));
      right: calc(24px + var(--safe-right));
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
    }
    
    .toast {
      pointer-events: auto;
      min-width: 280px;
      max-width: 420px;
      background: rgba(28,28,30,.95);
      color: #fff;
      padding: 14px 18px;
      border-radius: 14px;
      box-shadow: 0 8px 24px rgba(0,0,0,.3);
      font: 500 14px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial;
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,.1);
      animation: slideInRight .3s ease;
    }
    
    .toast.success {
      background: rgba(46, 204, 113, .95);
      border-color: rgba(46, 204, 113, .5);
    }
    
    .toast.error {
      background: rgba(231, 76, 60, .95);
      border-color: rgba(231, 76, 60, .5);
    }
    
    .toast.info {
      background: rgba(52, 152, 219, .95);
      border-color: rgba(52, 152, 219, .5);
    }
    /* Loading indicator */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: var(--accent);
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    @keyframes slideInRight {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    @media (hover: none) {
      .tab-btn:hover,
      .pill:hover,
      .card:hover,
      .suggestion-card:hover,
      .day-card:hover,
      .class-item:hover,
      .guest-card:hover,
      .btn:hover {
        transform: none;
        box-shadow: none;
      }
    }
    .hidden { display: none !important; }
    .fade-in { animation: fadeIn .3s ease both; }
    /* Debug Panel */
    .debug-panel {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,.9);
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      font-size: 11px;
      max-width: 300px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 10000;
    }
    .debug-panel.show {
      display: block;
    }
    /* Responsive - Tablet */
    @media (max-width: 1024px) {
      .calendar-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    /* Responsive - Mobile */
    @media (max-width: 768px) {
      body { padding-bottom: calc(80px + var(--safe-bottom)); }
      .container { margin-top: 12px; margin-bottom: 12px; }
      .nav {
        position: sticky;
        top: 0;
        flex-wrap: nowrap;
        gap: 8px;
        padding: 8px 12px;
        min-height: 44px;
        background: rgba(13, 21, 18, .98);
      }
      .brand span { font-size: 14px; }
      .brand svg { width: 24px; height: 24px; }
      #auth-container {
        margin-left: auto;
      }
      #auth-container #userDisplay {
        display: none !important;
      }
      #auth-container .btn {
        min-height: 40px;
        padding: 8px 12px;
        font-size: 13px;
      }
      /* Mobile bottom tab bar ‚Äî .tabs is moved to <body> via JS
         to escape .nav's containing block (sticky/backdrop-filter break position:fixed in WebKit) */
      body > .tabs {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 200;
        background: rgba(13, 21, 18, .98);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border-top: 1px solid rgba(255,255,255,.12);
        padding: 6px calc(8px + var(--safe-right)) calc(6px + var(--safe-bottom)) calc(8px + var(--safe-left));
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 2px;
      }
      body > .tabs .tab-btn {
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 4px;
        padding: 7px 2px 5px;
        border-radius: 10px;
        font-size: 10px;
        min-width: 0;
        min-height: 50px;
        border: 1px solid transparent;
        background: transparent;
      }
      body > .tabs .tab-btn .tab-icon { font-size: 20px; line-height: 1; }
      /* Show short labels on mobile via data-short attribute */
      body > .tabs .tab-btn .tab-label {
        display: block;
        max-width: 100%;
        font-size: 10px;
        font-weight: 600;
        line-height: 1.15;
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      body > .tabs .tab-btn .tab-label[data-short] {
        font-size: 0;
      }
      body > .tabs .tab-btn .tab-label[data-short]::after {
        content: attr(data-short);
        font-size: 10px;
        font-weight: 600;
      }
      body > .tabs .tab-btn[aria-selected="true"] {
        background: rgba(201,161,93,.25);
        border-color: rgba(201,161,93,.5);
        box-shadow: inset 0 0 0 1px rgba(201,161,93,.32);
      }
      .search-container { max-width: 100%; width: 100%; }
      .btn-sm, .search-clear, .modal__close, .status-toggle, .manager-tags-cell .add-tag-btn, .btn-remove-playlist { min-height: 44px; }
      .search-clear, .modal__close {
        width: 44px;
        height: 44px;
      }
      .search-container input {
        padding-right: 52px;
      }
      .search-container input,
      .search,
      .select,
      .form-group input,
      .form-group select,
      .form-group textarea,
      .add-playlist-form .input-field,
      .datetime-selector input,
      .tag-input-wrapper input {
        font-size: 16px;
      }
      .calendar-grid {
        grid-template-columns: 1fr;
      }
      .metric-row {
        grid-template-columns: repeat(3, 1fr);
      }
      .best-summary-title { font-size: 20px; }
      .best-insight { font-size: 12px; }
      .best-insight b { min-width: 32px; }
      .runner-actions .btn { width: 100%; justify-content: center; }
      .form-row {
        grid-template-columns: 1fr;
      }
      .datetime-selector {
        flex-direction: column;
        align-items: stretch;
      }
      .modal {
        padding: 0;
        align-items: flex-end;
      }
      .modal__content {
        width: 100%;
        max-width: none;
        max-height: calc(100dvh - var(--safe-top));
        border-radius: 20px 20px 0 0;
      }
      .modal__header {
        padding: 16px 16px 12px;
      }
      .modal__header h3 {
        font-size: 18px;
      }
      .modal__body {
        padding: 16px;
      }
      .modal__footer {
        position: sticky;
        bottom: 0;
        background: rgba(28, 45, 38, .98);
        padding: 12px 16px calc(12px + var(--safe-bottom));
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      .modal__footer .btn,
      .modal__footer .tooltip-wrapper,
      .modal__footer .tooltip-wrapper .btn {
        width: 100%;
      }
      .modal__footer .tooltip-wrapper { order: 1; }
      #save-draft-modal { order: 2; }
      #cancel-modal { order: 3; }
      #delete-class-modal {
        order: 4;
        margin-right: 0 !important;
      }
      .modal__footer .tooltip-text {
        display: none;
      }
      #history .table-container,
      #explorer .table-container {
        background: transparent;
        border: none;
        overflow: visible;
      }
      #history-table,
      #playlist-manager-table {
        display: block;
        width: 100%;
      }
      #history-table thead,
      #playlist-manager-table thead {
        display: none;
      }
      #history-table tbody,
      #playlist-manager-table tbody {
        display: grid;
        gap: 10px;
      }
      #history-table tr,
      #playlist-manager-table tr {
        display: block;
        background: rgba(255,255,255,.06);
        border: 1px solid rgba(255,255,255,.1);
        border-radius: 14px;
        overflow: hidden;
      }
      #history-table td,
      #playlist-manager-table td {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
        padding: 10px 12px;
        border-bottom: 1px solid rgba(255,255,255,.08);
      }
      #history-table td::before,
      #playlist-manager-table td::before {
        content: attr(data-label);
        flex: 0 0 38%;
        color: rgba(255,255,255,.62);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        line-height: 1.3;
      }
      #history-table td:last-child,
      #playlist-manager-table td:last-child {
        border-bottom: none;
      }
      #history-table td > :last-child,
      #playlist-manager-table td > :last-child {
        text-align: right;
      }
      #history-table td[colspan],
      #playlist-manager-table td[colspan],
      #playlist-manager-table .tag-editor-row td {
        display: block;
      }
      #history-table td[colspan]::before,
      #playlist-manager-table td[colspan]::before,
      #playlist-manager-table .tag-editor-row td::before {
        content: none;
      }
      #history-table .guest-names-short,
      #history-table .guest-names-full {
        text-align: right;
      }
      #toast-container {
        bottom: calc(96px + var(--safe-bottom));
        right: 12px;
        left: 12px;
      }
      .toast { min-width: unset; max-width: unset; }
    }
  </style>
</head>
<body>
  <nav class="nav">
    <div class="brand">
      <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <circle cx="24" cy="24" r="22" stroke="#c9a15d" stroke-width="2"/>
        <path d="M14 30C16 20 20 16 24 16C28 16 32 20 34 30" stroke="#c9a15d" stroke-width="3" stroke-linecap="round"/>
        <path d="M12 36H36" stroke="#c9a15d" stroke-width="2" stroke-linecap="round"/>
      </svg>
      <span>Hilo Playlist</span>
    </div>
    <div class="tabs" role="tablist">
      <button class="tab-btn" role="tab" aria-selected="true" data-tab="weekly"><span class="tab-icon" aria-hidden="true">&#128197;</span><span class="tab-label" data-short="Planner">Weekly Planner</span></button>
      <button class="tab-btn" role="tab" aria-selected="false" data-tab="dashboard"><span class="tab-icon" aria-hidden="true">&#9776;</span><span class="tab-label" data-short="Recs">Recommender</span></button>
      <button class="tab-btn" role="tab" aria-selected="false" data-tab="explorer"><span class="tab-icon" aria-hidden="true">&#9835;</span><span class="tab-label" data-short="Playlists">Playlists</span></button>
      <button class="tab-btn" role="tab" aria-selected="false" data-tab="history"><span class="tab-icon" aria-hidden="true">&#128214;</span><span class="tab-label" data-short="History">History</span></button>
      <button class="tab-btn" role="tab" aria-selected="false" data-tab="guests"><span class="tab-icon" aria-hidden="true">&#128101;</span><span class="tab-label" data-short="Guests">Guests</span></button>
      <button class="tab-btn" role="tab" aria-selected="false" data-tab="settings"><span class="tab-icon" aria-hidden="true">&#9881;</span><span class="tab-label" data-short="Settings">Settings</span></button>
    </div>
    <div id="auth-container" style="display:flex; align-items:center; gap:8px;">
      <button id="signInBtn" class="btn btn-primary btn-sm">Sign In</button>
      <span id="userDisplay" class="hidden" style="font-size:13px; color:rgba(255,255,255,.7);"></span>
      <button id="signOutBtn" class="btn btn-sm hidden">Sign Out</button>
    </div>
  </nav>
  <main class="container">
    <section id="dashboard" class="hidden fade-in">
      <div class="hero">
        <h1>Playlist Recommender</h1>
        <div class="subtle" id="currentDateTime"></div>
        
        <div id="connection-status" class="connection-status disconnected">
          <div class="status-dot disconnected"></div>
          <span>Not signed in</span>
        </div>
        
        <div class="step-label"><span class="step-num">1</span> Select Planned Classes</div>
        <div class="row" style="margin-top:0;">
          <div class="search-wrap" style="flex:1;">
            <select id="playlistWindow" class="select" title="Replay-ready window">
              <option value="45" selected>Replay-ready ‚â• 45 days</option>
              <option value="30">Replay-ready ‚â• 30 days</option>
              <option value="60">Replay-ready ‚â• 60 days</option>
              <option value="90">Replay-ready ‚â• 90 days</option>
            </select>
          </div>
        </div>
        <div class="class-picker-container" style="margin-top:8px;">
          <div class="class-picker-actions" style="display:flex; gap:8px; margin-bottom:6px;">
            <button type="button" class="btn-xs" id="selectAllDraftsBtn">Select All Drafts</button>
            <button type="button" class="btn-xs" id="clearAllClassesBtn">Clear All</button>
          </div>
          <div class="class-picker-list" id="plannedClassList" style="max-height:180px; overflow-y:auto; background:rgba(0,0,0,.15); border-radius:12px; border:1px solid rgba(255,255,255,.08); padding:8px;"></div>
        </div>
        <div class="row" style="margin-top:10px;">
          <span class="pill" id="selectedClassPill">No classes selected</span>
          <span class="pill" id="selectedClassTypePill">Class type: --</span>
          <span class="pill" id="selectedPlaylistPill">Assigned playlist: --</span>
          <span class="pill" id="recordsCountPill">0 records</span>
        </div>
      </div>
      <div class="step-label" style="margin-top:18px;"><span class="step-num">2</span> Recommendation</div>
      <div class="cards">
        <div class="card primary-card" id="bestCard">
          <div class="body">
            <div class="title">Best Fit Playlist</div>
            <div class="muted">Based on the selected class roster, date, and class type</div>
            <div id="bestSummary" style="margin-top:10px;"></div>
            <div id="bestStrength" class="best-strength-row"></div>
            <div class="recommender-explain">Ranked by never-heard coverage, replay-ready coverage, and median days since last played.</div>
            <div class="metric-row">
              <div class="metric">
                <div class="value" id="bestNever">--</div>
                <div class="label">Never-heard <span class="info-tip" tabindex="0">&#9432;<span class="tip-text">% of attendees who have never heard this playlist ‚Äî higher means better novelty</span></span></div>
              </div>
              <div class="metric">
                <div class="value" id="bestMedian">--</div>
                <div class="label">Median days <span class="info-tip" tabindex="0">&#9432;<span class="tip-text">Typical days since attendees last heard this playlist ‚Äî higher means less recent repetition</span></span></div>
              </div>
              <div class="metric">
                <div class="value" id="bestReady">--</div>
                <div class="label">Replay-ready <span class="info-tip" tabindex="0">&#9432;<span class="tip-text">% of attendees who last heard this at or before the replay-ready window</span></span></div>
              </div>
            </div>
            <div style="margin-top:14px; display:flex; gap:8px; flex-wrap:wrap;">
              <button class="btn btn-primary" id="assignBestPlaylistBtn">Assign Best Playlist</button>
              <button class="btn" id="previewRosterBtn">View Details</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="body">
            <div class="title">All Ranked Playlists</div>
            <div class="muted">Most recommended to least recommended for the selected class</div>
          </div>
          <div class="table-container dashboard-rankings-wrap" style="margin: 0 16px 16px;">
            <table class="data-table">
              <thead>
                <tr>
                  <th style="width:64px;">Rank</th>
                  <th>Playlist</th>
                  <th>Never-heard</th>
                  <th>Replay-ready</th>
                  <th>Median days</th>
                  <th>Recently heard</th>
                  <th>Score</th>
                  <th style="width:130px;">Action</th>
                </tr>
              </thead>
              <tbody id="runnerUps"></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>
    <section id="weekly" class="fade-in">
      <div class="hero">
        <h1>Weekly Class Planner</h1>
        <div class="subtle">Plan and manage your upcoming week of classes</div>
        
        <div class="row" style="margin-top:14px;">
          <div class="search-wrap" style="flex:1;">
            <button id="prevWeekBtn" class="btn">‚Üê Previous Week</button>
            <button id="currentWeekBtn" class="btn btn-info">Current Week</button>
            <button id="nextWeekBtn" class="btn">Next Week ‚Üí</button>
            <button id="syncAllBtn" class="btn btn-success" disabled>Finalize All Drafts</button>
          </div>
        </div>
        <div class="row" style="margin-top:10px;">
          <span class="pill" id="weekRangePill">Week of ...</span>
          <span class="pill status-draft" id="draftsCountPill">0 drafts</span>
          <span class="pill status-finalized" id="finalizedCountPill">0 finalized</span>
        </div>
      </div>
      <div class="calendar-grid" id="calendarGrid">
        </div>
    </section>
    <section id="explorer" class="hidden fade-in">
      <div class="hero">
        <h1>Playlist Manager</h1>
        <div class="subtle">Manage playlists, tags, and status</div>
        <button class="btn btn-primary" id="addPlaylistBtn" style="margin-top:12px;">+ Add Playlist</button>
      </div>
      <div id="addPlaylistForm" class="card add-playlist-form" style="display:none;">
        <div style="font-weight:600; font-size:14px; margin-bottom:8px;">New Playlist</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input type="text" id="newPlaylistId" placeholder="Playlist number (e.g. 13)" class="input-field" style="width:180px;" />
          <button class="btn btn-primary" id="confirmAddPlaylist">Add</button>
          <button class="btn btn-ghost" id="cancelAddPlaylist">Cancel</button>
        </div>
        <div id="addPlaylistError" style="color:var(--danger); font-size:13px; margin-top:6px; display:none;"></div>
      </div>
      <div class="card">
        <div class="table-container">
          <table class="data-table" id="playlist-manager-table">
            <thead>
              <tr>
                <th class="sortable" data-sort="playlist">Playlist</th>
                <th>Tags</th>
                <th class="sortable" data-sort="status">Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="explorerTbody"></tbody>
          </table>
        </div>
      </div>
    </section>
    <section id="history" class="hidden fade-in">
      <div class="section-header">
        <h2>Class History</h2>
        <div class="search-container">
          <input type="text" id="history-search" placeholder="Search classes...">
          <button type="button" class="search-clear" id="history-search-clear" aria-label="Clear search">‚úï</button>
        </div>
      </div>
      <div id="history-stats" class="stats-bar"></div>
      <div class="card">
        <div class="table-container">
          <table id="history-table" class="data-table">
            <thead>
              <tr>
                <th class="sortable" data-sort="datetime">Date & Time</th>
                <th class="sortable" data-sort="classType">Class Type</th>
                <th class="sortable" data-sort="playlist">Playlist</th>
                <th class="sortable" data-sort="count">Attendees</th>
                <th>Guest Names</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="historyTbody"></tbody>
          </table>
        </div>
      </div>
    </section>
    <section id="guests" class="hidden fade-in">
      <div class="section-header">
        <h2>Guest Profiles</h2>
        <div class="search-container">
          <input type="text" id="guest-search-filter" placeholder="Search guests...">
          <button type="button" class="search-clear" id="guest-filter-clear" aria-label="Clear search">‚úï</button>
        </div>
      </div>
      <div id="guests-stats" class="stats-bar"></div>
      <div id="guests-grid" class="guests-grid">
        <div class="empty-state">
          <h3>No guest data available</h3>
          <p>Sign in and import attendance data to see guest profiles</p>
        </div>
      </div>
    </section>
    <section id="settings" class="hidden fade-in">
      <div class="hero">
        <h1>Settings</h1>
        <div class="subtle">Manage your account and app data</div>
      </div>
      <div class="cards">
        <div class="card">
          <div class="body">
            <div class="title">Account</div>
            <div class="muted">Sign in with Google to sync your data across devices</div>
            <div id="settings-auth-info" style="margin-top:16px; padding: 12px; background: rgba(0,0,0,.1); border-radius: 8px; color: rgba(255,255,255,.9);">
              Not signed in
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:16px;">
              <button id="settingsSignInBtn" class="btn btn-primary">Sign In with Google</button>
              <button id="settingsSignOutBtn" class="btn hidden">Sign Out</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="body">
            <div class="title">Data Management</div>
            <div class="muted">Import/export your class data</div>

            <div style="margin-top:16px; display:flex; gap:8px; flex-wrap:wrap;">
              <button id="importCsvBtn" class="btn">&#128229; Import CSV</button>
              <button id="exportCsvBtn" class="btn">&#128228; Export CSV</button>
            </div>
            <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,.08);">
              <button id="clearDataBtn" class="btn btn-danger">&#128465; Clear All Data</button>
              <p style="margin:8px 0 0; font-size:12px; color:rgba(255,255,255,.5);">This permanently deletes all local and cloud data.</p>
            </div>
            <input id="fileInput" type="file" accept=".csv" class="hidden" />
          </div>
        </div>
      </div>
    </section>
    <div id="class-modal" class="modal hidden">
      <div class="modal__content">
        <div class="modal__header">
          <h3 id="class-modal-title">Plan Class</h3>
          <button id="close-class-modal" class="modal__close">&times;</button>
        </div>
        <div class="modal__body">
          <div class="form-row">
            <div class="form-group">
              <label for="modal-class-date">Date</label>
              <input type="date" id="modal-class-date">
            </div>
            <div class="form-group">
              <label for="modal-class-time">Time</label>
              <select id="modal-class-time" class="select"></select>
            </div>
          </div>

          <div class="form-group">
            <label for="modal-class-type">Class Type</label>
            <select id="modal-class-type">
              <option value="">All Types</option>
            </select>
          </div>

          <div class="form-group">
            <label>Attendees</label>
            <div class="guest-selector">
              <div class="guest-selector-header">
                <div class="search-container no-icon" style="max-width:100%; flex:1;">
                  <input type="text" id="modal-guest-search" placeholder="Search guests...">
                  <button type="button" class="search-clear" id="modal-guest-search-clear" aria-label="Clear search">‚úï</button>
                </div>
                <div class="guest-selector-actions">
                  <button type="button" class="btn-xs" id="modalSelectAllBtn">Select All</button>
                  <button type="button" class="btn-xs" id="modalClearAllBtn">Clear All</button>
                </div>
              </div>

              <div class="guest-list-container" style="max-height: 200px;">
                <div class="guest-list" id="modal-guest-list"></div>
              </div>

              <div class="selected-guests-container">
                <div class="selected-guests" id="modal-selected-guests">
                  <div class="no-selection">No guests selected</div>
                </div>
              </div>
            </div>
          </div>

          <div class="form-group">
            <label>Playlist</label>
            <div id="modal-class-playlist-display" class="pill status-info" style="display:flex; width:100%; justify-content:flex-start;">No playlist assigned yet</div>
            <input id="modal-class-playlist" type="hidden" value="">
            <div class="subtle" style="font-size:12px; margin-top:8px;">Assign playlist from the Recommender tab.</div>
          </div>

          <div class="form-group">
            <label for="modal-class-notes">Notes (optional)</label>
            <textarea id="modal-class-notes" placeholder="Add any notes about this class..."></textarea>
          </div>
        </div>
         <div class="modal__footer">
            <button id="delete-class-modal" class="btn btn-danger" style="margin-right: auto;">üóëÔ∏è Delete</button>
            <button id="cancel-modal" class="btn">Cancel</button>
            <button id="save-draft-modal" class="btn btn-warning">üíæ Save as Draft</button>
            <div class="tooltip-wrapper">
              <button id="finalize-modal" class="btn btn-success">‚úî Finalize</button>
              <span class="tooltip-text">Saves class &amp; records attendance for all attendees</span>
            </div>
        </div>
      </div>
    </div>
    <div id="guest-modal" class="modal hidden">
      <div class="modal__content">
        <div class="modal__header">
          <h3 id="guest-modal-title">Guest Profile</h3>
          <button id="close-guest-modal" class="modal__close">&times;</button>
        </div>
        <div class="modal__body" id="guest-modal-body">
          <div id="guest-modal-content"></div>
        </div>
      </div>
    </div>
  </main>
  <div id="debug-panel" class="debug-panel">
    <strong>Debug Info:</strong>
    <div id="debug-content"></div>
  </div>
<!-- Firebase SDK (compat for no-build-tool usage) -->
<script src="https://www.gstatic.com/firebasejs/11.3.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.3.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.3.0/firebase-firestore-compat.js"></script>
<script>
  // --- Firebase Configuration ---
  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyA5wVOEPafDg27_Jc-Ixn_03jFb6t2IedM",
    authDomain: "hilo-playlist-app.firebaseapp.com",
    projectId: "hilo-playlist-app",
    storageBucket: "hilo-playlist-app.firebasestorage.app",
    messagingSenderId: "13713370156",
    appId: "1:13713370156:web:2380816951b9c48c4a7589"
  };

  firebase.initializeApp(FIREBASE_CONFIG);
  const auth = firebase.auth();
  const db = firebase.firestore();
  db.enablePersistence({ synchronizeTabs: true }).catch(err => {
    if (err.code === 'failed-precondition') {
      console.warn('Firestore persistence unavailable: multiple tabs open');
    }
  });
  // --- Debug Mode ---
  const DEBUG_MODE = false; // Set to true to enable debug logging
  function debugLog(...args) {
    if (DEBUG_MODE) {
      console.log('[DEBUG]', ...args);
      const panel = document.getElementById('debug-panel');
      const content = document.getElementById('debug-content');
      if (panel && content) {
        panel.classList.add('show');
        const timestamp = new Date().toLocaleTimeString();
        content.innerHTML = `<div>${timestamp}: ${args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' ')}</div>` + content.innerHTML;
        const messages = content.querySelectorAll('div');
        if (messages.length > 20) {
          messages[messages.length - 1].remove();
        }
      }
    }
  }
  // --- App State ---
  const DEFAULT_PLAYLISTS = Array.from({ length: 12 }, (_, i) => String(i + 1));
  const PREDEFINED_CLASS_TYPES = [];
  const state = {
    modalAttendees: new Set(),
    playlists: [...DEFAULT_PLAYLISTS],
    records: [], // Historical records with date, time, guest, playlist
    selectedWindow: 45,
    allGuests: new Set(),
    sortOrder: { column: 'datetime', ascending: false },
    explorerSortOrder: { column: 'playlist', ascending: true },
    
    // Firebase integration
    firebaseUser: null,
    firestoreConnected: false,
    firestoreHasPendingWrites: false,
    unsubRecords: null,
    unsubClasses: null,
    unsubPlaylists: null,
    playlistTags: new Map(),
    playlistStatus: new Map(),
    expandedPlaylist: null,

    // Weekly planner state
    weeklyPlan: new Map(), // DateTime string -> class object
    currentWeekStart: null,
    selectedClass: null, // Holds the class being edited in the modal

    // Current selection for recommender
    selectedRecommendationClassKey: '',
    selectedRecommendationClassKeys: new Set()
  };
  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));
  function normalizePlaylistId(value) {
    if (value === null || value === undefined) return '';
    let raw = typeof value === 'number'
      ? (Number.isFinite(value) ? String(value) : '')
      : String(value).trim();
    if (!raw) return '';
    raw = raw.replace(/^playlist\s*#?/i, '').trim();
    if (!raw) return '';
    if (!/^\d+(\.\d+)?$/.test(raw)) return '';
    if (raw.includes('.')) {
      raw = raw.replace(/(\.\d*?[1-9])0+$/, '$1').replace(/\.0+$/, '').replace(/\.$/, '');
    }
    return raw;
  }
  function comparePlaylistIds(a, b) {
    const aId = normalizePlaylistId(a);
    const bId = normalizePlaylistId(b);
    const aNum = aId && /^\d+(\.\d+)?$/.test(aId) ? Number(aId) : NaN;
    const bNum = bId && /^\d+(\.\d+)?$/.test(bId) ? Number(bId) : NaN;
    if (!Number.isNaN(aNum) && !Number.isNaN(bNum) && aNum !== bNum) return aNum - bNum;
    if (!Number.isNaN(aNum) && Number.isNaN(bNum)) return -1;
    if (Number.isNaN(aNum) && !Number.isNaN(bNum)) return 1;
    return aId.localeCompare(bId, undefined, { numeric: true, sensitivity: 'base' });
  }
  function normalizePlaylistStatus(value) {
    const raw = (value ?? '').toString().trim();
    if (!raw) return '';
    const lower = raw.toLowerCase();
    if (lower === 'active') return 'Active';
    if (lower === 'retired') return 'Retired';
    if (lower === 'removed') return 'Removed';
    return raw;
  }
  function ensurePlaylistInState(playlistId) {
    const normalized = normalizePlaylistId(playlistId);
    if (!normalized) return;
    if (!state.playlists.includes(normalized)) {
      state.playlists.push(normalized);
      state.playlists.sort(comparePlaylistIds);
    }
  }
  function rebuildPlaylistsFromData() {
    const found = new Set();
    const removed = new Set();
    state.playlistStatus.forEach((status, playlistId) => {
      const normalized = normalizePlaylistId(playlistId);
      if (!normalized) return;
      if (normalizePlaylistStatus(status) === 'Removed') {
        removed.add(normalized);
      }
    });
    const addIfVisible = (playlistId) => {
      const normalized = normalizePlaylistId(playlistId);
      if (!normalized || removed.has(normalized)) return;
      found.add(normalized);
    };
    state.records.forEach(r => {
      addIfVisible(r.playlist);
    });
    state.weeklyPlan.forEach(cls => {
      addIfVisible(cls.playlist);
    });
    state.playlistTags.forEach((_, playlistId) => {
      addIfVisible(playlistId);
    });
    state.playlistStatus.forEach((status, playlistId) => {
      const normalized = normalizePlaylistId(playlistId);
      if (!normalized) return;
      if (normalizePlaylistStatus(status) === 'Removed') return;
      found.add(normalized);
    });
    const fallbackPlaylists = [...DEFAULT_PLAYLISTS].filter(playlistId => !removed.has(playlistId));
    state.playlists = (found.size > 0 ? Array.from(found) : fallbackPlaylists).sort(comparePlaylistIds);
  }
  // HTML escape for safe innerHTML interpolation
  function esc(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }
  function renderPlaylistTags(playlistNum, opts = {}) {
    const playlistId = normalizePlaylistId(playlistNum);
    const tags = playlistId ? (state.playlistTags.get(playlistId) || []) : [];
    if (tags.length === 0) return '';
    const cls = opts.compact ? 'class-type-tag compact' : 'class-type-tag';
    return '<span class="playlist-tags-inline">' + tags.map(t => `<span class="${cls}">${esc(t)}</span>`).join('') + '</span>';
  }
  function getAllClassTypes() {
    const types = new Set(PREDEFINED_CLASS_TYPES);
    state.playlistTags.forEach(tags => tags.forEach(t => types.add(t)));
    state.records.forEach(r => { if (r.classType) types.add(r.classType); });
    state.weeklyPlan.forEach(cls => { if (cls.classType) types.add(cls.classType); });
    return Array.from(types).sort();
  }
  function populateClassTypeDropdown(selectEl, selectedValue) {
    const current = selectedValue || '';
    selectEl.innerHTML = '<option value="">All Types</option>';
    getAllClassTypes().forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      if (t === current) opt.selected = true;
      selectEl.appendChild(opt);
    });
  }
  function normalizeTime(timeStr, fallback = '09:00') {
    const raw = (timeStr ?? '').toString().trim();
    if (!raw) return fallback;
    const cleaned = raw.replace(/^\d{4}-\d{2}-\d{2}[T\s]+/, '').trim();
    const match = cleaned.match(/^(\d{1,2})(?::(\d{1,2}))?(?::\d{1,2})?\s*([AaPp][Mm])?$/);
    if (!match) return fallback;
    let hours = Number.parseInt(match[1], 10);
    const minutes = Number.parseInt(match[2] ?? '0', 10);
    if (Number.isNaN(hours) || Number.isNaN(minutes)) return fallback;
    const meridiem = (match[3] || '').toUpperCase();
    if (meridiem === 'PM' && hours < 12) hours += 12;
    if (meridiem === 'AM' && hours === 12) hours = 0;
    return `${String(Math.max(0, Math.min(23, hours))).padStart(2, '0')}:${String(Math.max(0, Math.min(59, minutes))).padStart(2, '0')}`;
  }
  function populateTimeSelect(selectEl, selectedTime) {
    selectEl.innerHTML = '';
    for (let h = 5; h <= 22; h++) {
      for (let m = 0; m < 60; m += 15) {
        const val = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        const hour12 = h === 0 ? 12 : h > 12 ? h - 12 : h;
        const ampm = h < 12 ? 'AM' : 'PM';
        const label = `${hour12}:${String(m).padStart(2, '0')} ${ampm}`;
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = label;
        selectEl.appendChild(opt);
      }
    }
    const nearest = snapToNearest15(selectedTime || '09:00');
    if (selectEl.querySelector(`option[value="${nearest}"]`)) {
      selectEl.value = nearest;
    } else {
      selectEl.value = '09:00';
    }
  }
  function snapToNearest15(timeStr) {
    const normalized = normalizeTime(timeStr);
    const [h, m] = normalized.split(':').map(Number);
    const snapped = Math.round(m / 15) * 15;
    const finalM = snapped === 60 ? 0 : snapped;
    const finalH = snapped === 60 ? Math.min(h + 1, 22) : h;
    return `${String(finalH).padStart(2, '0')}:${String(finalM).padStart(2, '0')}`;
  }
  function normalizeClassNumber(value) {
    return (value || '').toString().trim().replace(/\s+/g, ' ');
  }
  function parseImportedPlaylist(rawValue) {
    const raw = (rawValue || '').toString().trim();
    if (!raw) return { playlistId: '', inferredStatus: '' };
    const direct = normalizePlaylistId(raw);
    const inferredStatus = /\bretired\b/i.test(raw) ? 'Retired' : '';
    if (direct) return { playlistId: direct, inferredStatus };
    const match = raw.match(/\d+(\.\d+)?/);
    if (!match) return { playlistId: '', inferredStatus };
    return { playlistId: normalizePlaylistId(match[0]), inferredStatus };
  }
  function buildRecordKey(record) {
    const classNumber = normalizeClassNumber(record.classNumber);
    const base = `${record.date}|${normalizeTime(record.time)}|${(record.guest || '').trim()}|${record.playlist}`;
    return classNumber ? `${base}|${classNumber}` : base;
  }
  function normalizeRecord(record) {
    if (!record) return null;
    const guest = (record.guest || '').toString().trim();
    const playlist = normalizePlaylistId(record.playlist);
    if (!guest || !playlist) return null;
    let date = '';
    if (typeof record.date === 'string') {
      const rawDate = record.date.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(rawDate)) {
        date = rawDate;
      } else if (/^\d{4}-\d{2}-\d{2}T/.test(rawDate)) {
        date = rawDate.slice(0, 10);
      } else {
        const parsedDate = new Date(rawDate);
        if (!Number.isNaN(parsedDate.getTime())) {
          date = formatDateKey(parsedDate);
        }
      }
    } else {
      const parsedDate = new Date(record.date);
      if (!Number.isNaN(parsedDate.getTime())) {
        date = formatDateKey(parsedDate);
      }
    }
    if (!date || !/^\d{4}-\d{2}-\d{2}$/.test(date)) return null;
    return {
      date,
      time: normalizeTime(record.time),
      guest,
      playlist,
      classType: (record.classType || '').toString().trim(),
      classNumber: normalizeClassNumber(record.classNumber || record.classNum)
    };
  }
  // Deduplicate records before pushing
  function addRecordIfNew(record) {
    const normalizedRecord = normalizeRecord(record);
    if (!normalizedRecord) return false;
    const key = buildRecordKey(normalizedRecord);
    const exists = state.records.some(r => buildRecordKey(r) === key);
    if (!exists) {
      state.records.push(normalizedRecord);
      ensurePlaylistInState(normalizedRecord.playlist);
      return true;
    }
    return false;
  }
  // --- Firestore Document ID Helper ---
  function safeDocId(recordKey) {
    let hash = 0x811c9dc5;
    for (let i = 0; i < recordKey.length; i++) {
      hash ^= recordKey.charCodeAt(i);
      hash = Math.imul(hash, 0x01000193);
    }
    const prefix = recordKey.slice(0, 40).replace(/[^a-zA-Z0-9_-]/g, '_');
    return prefix + '__' + (hash >>> 0).toString(36);
  }
  // --- Firebase Data Layer ---
   function setLoading(button, isLoading) {
    if (!button) return;
    if (isLoading) {
      button.disabled = true;
      button.dataset.originalContent = button.innerHTML;
      button.innerHTML = '<div class="loading-spinner"></div>';
    } else {
      button.disabled = false;
      if (button.dataset.originalContent) {
        button.innerHTML = button.dataset.originalContent;
      }
    }
  }
  // --- Firestore Real-time Listeners ---
  function setupFirestoreListeners() {
    if (state.unsubRecords) state.unsubRecords();
    if (state.unsubClasses) state.unsubClasses();
    if (state.unsubPlaylists) state.unsubPlaylists();

    const uid = state.firebaseUser.uid;

    state.unsubRecords = db.collection('users').doc(uid).collection('records')
      .onSnapshot(snapshot => {
        state.firestoreConnected = !snapshot.metadata.fromCache;
        state.firestoreHasPendingWrites = snapshot.metadata.hasPendingWrites;
        updateConnectionStatus();

        state.records = [];
        state.allGuests = new Set();
        snapshot.forEach(doc => {
          const normalized = normalizeRecord(doc.data());
          if (!normalized) return;
          state.records.push(normalized);
          state.allGuests.add(normalized.guest);
        });
        state.weeklyPlan.forEach(cls => {
          (cls.attendees instanceof Set ? cls.attendees : []).forEach(g => state.allGuests.add(g));
        });
        rebuildPlaylistsFromData();
        updateRecordsPill();
        refreshAll();
        refreshHistory();
        refreshGuests();
        saveStateToLocalStorage();
      }, error => {
        console.error('Records listener error:', error);
        showToast('Data sync error: ' + error.message, 'error');
      });

    state.unsubClasses = db.collection('users').doc(uid).collection('classes')
      .onSnapshot(snapshot => {
        state.weeklyPlan = new Map();
        state.allGuests = new Set(state.records.map(r => r.guest).filter(Boolean));
        snapshot.forEach(doc => {
          const cls = doc.data();
          cls.id = doc.id;
          cls.playlist = normalizePlaylistId(cls.playlist);
          cls.attendees = new Set(cls.attendees || []);
          cls.classType = (cls.classType || '').toString().trim();
          const key = createDateTimeKey(cls.date, cls.time);
          state.weeklyPlan.set(key, cls);
          cls.attendees.forEach(g => state.allGuests.add(g));
        });
        rebuildPlaylistsFromData();
        renderWeeklyCalendar();
        refreshAll();
        refreshGuests();
        saveStateToLocalStorage();
      }, error => {
        console.error('Classes listener error:', error);
      });

    state.unsubPlaylists = db.collection('users').doc(uid).collection('playlists')
      .onSnapshot(snapshot => {
        state.playlistTags = new Map();
        state.playlistStatus = new Map();
        snapshot.forEach(doc => {
          const data = doc.data();
          const playlistId = normalizePlaylistId(doc.id);
          if (!playlistId) return;
          if (Array.isArray(data.classTypes)) {
            const tags = data.classTypes.map(t => (t ?? '').toString().trim()).filter(Boolean);
            if (tags.length > 0) state.playlistTags.set(playlistId, Array.from(new Set(tags)));
          }
          const status = normalizePlaylistStatus(data.status);
          if (status) state.playlistStatus.set(playlistId, status);
        });
        rebuildPlaylistsFromData();
        refreshAll();
        saveStateToLocalStorage();
      }, error => {
        console.error('Playlists listener error:', error);
      });
  }

  // --- Auth State Observer ---
  function setupAuthListener() {
    auth.onAuthStateChanged(user => {
      state.firebaseUser = user;
      if (user) {
        $('#signInBtn').classList.add('hidden');
        $('#userDisplay').textContent = user.displayName || user.email;
        $('#userDisplay').classList.remove('hidden');
        $('#signOutBtn').classList.remove('hidden');
        $('#settingsSignInBtn').classList.add('hidden');
        $('#settingsSignOutBtn').classList.remove('hidden');
        const infoEl = $('#settings-auth-info');
        if (infoEl) infoEl.textContent = `Signed in as ${user.displayName || user.email}`;
        updateConnectionStatus();
        setupFirestoreListeners();
      } else {
        if (state.unsubRecords) { state.unsubRecords(); state.unsubRecords = null; }
        if (state.unsubClasses) { state.unsubClasses(); state.unsubClasses = null; }
        if (state.unsubPlaylists) { state.unsubPlaylists(); state.unsubPlaylists = null; }
        state.playlistTags = new Map();
        state.playlistStatus = new Map();
        $('#signInBtn').classList.remove('hidden');
        $('#userDisplay').classList.add('hidden');
        $('#signOutBtn').classList.add('hidden');
        $('#settingsSignInBtn').classList.remove('hidden');
        $('#settingsSignOutBtn').classList.add('hidden');
        const infoEl = $('#settings-auth-info');
        if (infoEl) infoEl.textContent = 'Not signed in';
        state.firestoreConnected = false;
        rebuildPlaylistsFromData();
        updateConnectionStatus();
      }
    });
  }

  // --- Firestore Write Functions ---
  async function writeRecordsToFirestore(classData) {
    if (!state.firebaseUser) {
      showToast('Please sign in first.', 'error');
      return false;
    }
    const uid = state.firebaseUser.uid;
    const batch = db.batch();
    const recordsRef = db.collection('users').doc(uid).collection('records');

    for (const guest of classData.attendees) {
      const recordKey = buildRecordKey({
        date: classData.date,
        time: normalizeTime(classData.time),
        guest,
        playlist: classData.playlist
      });
      const docRef = recordsRef.doc(safeDocId(recordKey));
      batch.set(docRef, {
        date: classData.date,
        time: normalizeTime(classData.time),
        guest,
        playlist: classData.playlist,
        recordKey
      });
    }

    try {
      await batch.commit();
      showToast(`Synced ${classData.attendees.size} records`, 'success');
      return true;
    } catch (error) {
      showToast('Sync failed: ' + error.message, 'error');
      return false;
    }
  }

  async function saveClassToFirestore(dateTimeKey, classData) {
    if (!state.firebaseUser) {
      showToast('Please sign in first.', 'error');
      return false;
    }
    const uid = state.firebaseUser.uid;
    const docId = safeDocId(dateTimeKey);
    try {
      await db.collection('users').doc(uid).collection('classes').doc(docId).set({
        date: classData.date,
        time: classData.time,
        playlist: classData.playlist,
        attendees: Array.from(classData.attendees),
        status: classData.status || 'draft',
        notes: classData.notes || '',
        classType: classData.classType || '',
        dateTimeKey
      });
      return true;
    } catch (error) {
      showToast('Save failed: ' + error.message, 'error');
      return false;
    }
  }

  async function deleteClassFromFirestore(dateTimeKey) {
    if (!state.firebaseUser) return;
    const uid = state.firebaseUser.uid;
    const docId = safeDocId(dateTimeKey);
    await db.collection('users').doc(uid).collection('classes').doc(docId).delete();
  }

  async function clearAllFirestoreData() {
    if (!state.firebaseUser) return;
    const uid = state.firebaseUser.uid;
    const collections = ['records', 'classes', 'playlists'];
    for (const col of collections) {
      let snapshot;
      do {
        snapshot = await db.collection('users').doc(uid).collection(col).limit(500).get();
        if (snapshot.empty) break;
        const batch = db.batch();
        snapshot.docs.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
      } while (!snapshot.empty);
    }
  }
  async function upsertPlaylistMetadata(playlistId, payload) {
    if (!state.firebaseUser || !playlistId) return;
    const keys = Object.keys(payload || {});
    if (keys.length === 0) return;
    await db.collection('users').doc(state.firebaseUser.uid)
      .collection('playlists').doc(playlistId)
      .set(payload, { merge: true });
  }
  async function setPlaylistStatus(playlistNum, status) {
    const playlistId = normalizePlaylistId(playlistNum);
    const normalizedStatus = normalizePlaylistStatus(status);
    if (!playlistId || !normalizedStatus) return;
    state.playlistStatus.set(playlistId, normalizedStatus);
    ensurePlaylistInState(playlistId);
    saveStateToLocalStorage();
    refreshAll();
    if (state.firebaseUser) {
      try {
        await upsertPlaylistMetadata(playlistId, { status: normalizedStatus });
      } catch (err) {
        showToast('Playlist status save failed: ' + err.message, 'error');
      }
    }
  }
  async function addPlaylistTag(playlistNum, tag) {
    const playlistId = normalizePlaylistId(playlistNum);
    if (!playlistId) return;
    const trimmed = tag.trim();
    if (!trimmed) return;
    const current = state.playlistTags.get(playlistId) || [];
    if (current.includes(trimmed)) return;
    const updated = [...current, trimmed];
    state.playlistTags.set(playlistId, updated);
    ensurePlaylistInState(playlistId);
    saveStateToLocalStorage();
    refreshAll();
    if (state.firebaseUser) {
      try {
        await upsertPlaylistMetadata(playlistId, { classTypes: updated });
      } catch (err) {
        showToast('Tag save failed: ' + err.message, 'error');
      }
    }
  }
  async function removePlaylistTag(playlistNum, tag) {
    const playlistId = normalizePlaylistId(playlistNum);
    if (!playlistId) return;
    const current = state.playlistTags.get(playlistId) || [];
    const updated = current.filter(t => t !== tag);
    if (updated.length > 0) {
      state.playlistTags.set(playlistId, updated);
    } else {
      state.playlistTags.delete(playlistId);
    }
    rebuildPlaylistsFromData();
    saveStateToLocalStorage();
    refreshAll();
    if (state.firebaseUser) {
      try {
        await upsertPlaylistMetadata(playlistId, { classTypes: updated });
      } catch (err) {
        showToast('Tag remove failed: ' + err.message, 'error');
      }
    }
  }
  async function addNewPlaylist(rawId) {
    const playlistId = normalizePlaylistId(rawId);
    if (!playlistId) return { ok: false, error: 'Invalid playlist number. Use a numeric value (e.g. 13 or 2.5).' };
    if (state.playlists.includes(playlistId)) return { ok: false, error: `Playlist #${playlistId} already exists.` };
    state.playlists.push(playlistId);
    state.playlists.sort(comparePlaylistIds);
    state.playlistStatus.set(playlistId, 'Active');
    saveStateToLocalStorage();
    refreshAll();
    if (state.firebaseUser) {
      try {
        await upsertPlaylistMetadata(playlistId, { status: 'Active', classTypes: [] });
      } catch (err) {
        showToast('Playlist save failed: ' + err.message, 'error');
      }
    }
    showToast(`Playlist #${playlistId} added`, 'success');
    return { ok: true };
  }
  async function removePlaylist(playlistNum) {
    const playlistId = normalizePlaylistId(playlistNum);
    if (!playlistId) return;
    // Check for upcoming classes using this playlist
    const upcoming = Array.from(state.weeklyPlan.values()).filter(
      c => normalizePlaylistId(c.playlist) === playlistId && c.status !== 'finalized'
    );
    if (upcoming.length > 0) {
      if (!confirm(`Playlist #${playlistId} is assigned to ${upcoming.length} upcoming class(es). Remove anyway?`)) return;
    } else {
      if (!confirm(`Remove Playlist #${playlistId}? Historical records will be kept.`)) return;
    }
    state.playlists = state.playlists.filter(p => p !== playlistId);
    state.playlistTags.delete(playlistId);
    state.playlistStatus.set(playlistId, 'Removed');
    if (state.expandedPlaylist === playlistId) state.expandedPlaylist = null;
    rebuildPlaylistsFromData();
    saveStateToLocalStorage();
    refreshAll();
    if (state.firebaseUser) {
      try {
        await upsertPlaylistMetadata(playlistId, { status: 'Removed', classTypes: [] });
      } catch (err) {
        showToast('Playlist delete failed: ' + err.message, 'error');
      }
    }
    showToast(`Playlist #${playlistId} removed`, 'success');
  }
  // --- Local Storage Persistence ---
  function saveStateToLocalStorage() {
      try {
          // Convert weeklyPlan entries: attendees Set -> Array so JSON.stringify works
          const weeklyPlanSerialized = Array.from(state.weeklyPlan.entries()).map(([key, cls]) => [
              key,
              { ...cls, attendees: Array.from(cls.attendees || []) }
          ]);
          const dataToSave = {
              records: state.records,
              weeklyPlan: weeklyPlanSerialized,
              allGuests: Array.from(state.allGuests),
              playlistTags: Array.from(state.playlistTags.entries()),
              playlistStatus: Array.from(state.playlistStatus.entries())
          };
          localStorage.setItem('hiloPlaylistData', JSON.stringify(dataToSave));
          debugLog('State saved to localStorage');
      } catch (e) {
          console.error("Failed to save state to localStorage", e);
      }
  }
  function loadStateFromLocalStorage() {
      try {
          const savedData = localStorage.getItem('hiloPlaylistData');
          if (savedData) {
              const parsedData = JSON.parse(savedData);
              state.records = [];
              (parsedData.records || []).forEach(r => addRecordIfNew(r));
              const normalizedWeeklyPlan = new Map();
              new Map(parsedData.weeklyPlan || []).forEach((cls, key) => {
                  const parsedKey = parseDateTimeKey(key);
                  cls.date = cls.date || parsedKey.date;
                  cls.time = normalizeTime(cls.time || parsedKey.time || '09:00');
                  cls.playlist = normalizePlaylistId(cls.playlist);
                  cls.id = cls.id || `${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
                  if (Array.isArray(cls.attendees)) {
                      cls.attendees = new Set(cls.attendees);
                  } else if (!(cls.attendees instanceof Set)) {
                      cls.attendees = new Set();
                  }
                  const normalizedKey = createDateTimeKey(cls.date, cls.time);
                  if (!normalizedWeeklyPlan.has(normalizedKey)) {
                      normalizedWeeklyPlan.set(normalizedKey, cls);
                  }
              });
              state.weeklyPlan = normalizedWeeklyPlan;
              state.playlistTags = new Map();
              (parsedData.playlistTags || []).forEach(entry => {
                const [playlistId, tags] = entry;
                const normalizedId = normalizePlaylistId(playlistId);
                if (!normalizedId || !Array.isArray(tags)) return;
                const cleanedTags = tags.map(t => (t ?? '').toString().trim()).filter(Boolean);
                if (cleanedTags.length > 0) state.playlistTags.set(normalizedId, Array.from(new Set(cleanedTags)));
              });
              state.playlistStatus = new Map();
              (parsedData.playlistStatus || []).forEach(entry => {
                const [playlistId, status] = entry;
                const normalizedId = normalizePlaylistId(playlistId);
                const normalizedStatus = normalizePlaylistStatus(status);
                if (!normalizedId || !normalizedStatus) return;
                state.playlistStatus.set(normalizedId, normalizedStatus);
              });
              state.allGuests = new Set(parsedData.allGuests || []);
              // Rebuild allGuests from records in case saved guest list was incomplete
              state.records.forEach(r => { if (r.guest) state.allGuests.add(r.guest); });
              state.weeklyPlan.forEach(cls => cls.attendees.forEach(guest => state.allGuests.add(guest)));
              rebuildPlaylistsFromData();
              debugLog('State loaded from localStorage');
          }
      } catch (e) {
          console.error("Failed to load state from localStorage", e);
      }
  }
  // --- Utility Functions ---
  const parseDateInput = (d) => {
    if (!d) return null;
    if (typeof d === 'number' || (typeof d === 'string' && /^\d+(\.\d+)?$/.test(d.trim()))) {
      const serial = Number(d);
      if (Number.isFinite(serial) && serial > 59) {
        const wholeDays = Math.trunc(serial);
        const dayFraction = serial - wholeDays;
        const utcMs = Date.UTC(1899, 11, 30) + (wholeDays * 86400 * 1000) + Math.round(dayFraction * 86400 * 1000);
        const excelDate = new Date(utcMs);
        if (!Number.isNaN(excelDate.getTime())) {
          return new Date(
            excelDate.getUTCFullYear(),
            excelDate.getUTCMonth(),
            excelDate.getUTCDate(),
            excelDate.getUTCHours(),
            excelDate.getUTCMinutes(),
            excelDate.getUTCSeconds(),
            excelDate.getUTCMilliseconds()
          );
        }
      }
    }
    const parsed = (typeof d === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(d))
      ? new Date(d + 'T00:00:00')
      : new Date(d);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  };
  const formatDate = (d) => {
    if (!d) return '';
    const date = parseDateInput(d);
    if (!date) return '';
    return date.toLocaleDateString('en-US', {
      weekday: 'short',
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  };
  const formatTime = (timeStr) => {
    if (!timeStr) return '';
    const [hours, minutes] = timeStr.split(':');
    const hour = parseInt(hours, 10);
    const ampm = hour >= 12 ? 'PM' : 'AM';
    const displayHour = hour % 12 || 12;
    return `${displayHour}:${String(minutes).padStart(2, '0')} ${ampm}`;
  };
  const formatDateTime = (date, time) => {
    return `${formatDate(date)} at ${formatTime(time)}`;
  };
  const createDateTimeKey = (date, time) => {
    return `${date}T${normalizeTime(time)}`;
  };
  const parseDateTimeKey = (key) => {
    const [date, time] = key.split('T');
    return { date, time: normalizeTime(time) };
  };
  const daysBetween = (referenceDate, comparedDate) => {
    const date1 = parseDateInput(referenceDate);
    const date2 = parseDateInput(comparedDate);
    if (!date1 || !date2) return 0;
    const diffTime = date1.getTime() - date2.getTime();
    return Math.floor(diffTime / (1000 * 60 * 60 * 24));
  };
  const median = (arr) => {
    if (!arr.length) return 0;
    const sorted = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 ? sorted[mid] : Math.round((sorted[mid - 1] + sorted[mid]) / 2);
  };
  const getWeekStart = (date) => {
    const d = parseDateInput(date) || new Date();
    d.setHours(0, 0, 0, 0);
    const day = d.getDay();
    const diff = d.getDate() - day; // Sunday = 0
    return new Date(d.setDate(diff));
  };
  const getWeekDays = (weekStart) => {
    const days = [];
    for (let i = 0; i < 7; i++) {
      const day = new Date(weekStart);
      day.setDate(weekStart.getDate() + i);
      days.push(day);
    }
    return days;
  };
  const formatDateKey = (date) => {
    // Use local date components instead of UTC-based toISOString()
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');
    return `${y}-${m}-${d}`;
  };
  // --- Initialize App ---
  async function initializeApp() {
    debugLog('Initializing app...');

    // Move tabs out of .nav on mobile so position:fixed works correctly.
    // WebKit treats sticky/backdrop-filter parents as containing blocks for fixed children.
    (function() {
      const tabs = document.querySelector('.tabs');
      const nav = document.querySelector('.nav');
      const auth = document.getElementById('auth-container');
      const mq = window.matchMedia('(max-width: 768px)');
      function place(e) {
        if (e.matches) document.body.appendChild(tabs);
        else nav.insertBefore(tabs, auth);
      }
      mq.addEventListener('change', place);
      place(mq);
    })();

    loadStateFromLocalStorage();

    const today = new Date();
    state.currentWeekStart = getWeekStart(today);

    // Wire up UI immediately so the app is interactive while Firebase loads
    addEventListeners();
    updateConnectionStatus();
    updateDashboardStatus();
    updateRecordsPill();
    refreshAll();
    renderWeeklyCalendar();

    // Start Firebase auth listener ‚Äî Firestore listeners start on sign-in
    setupAuthListener();
  }
  function updateCurrentDateTime() {
    const now = new Date();
    $("#currentDateTime").textContent = now.toLocaleDateString('en-US', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  }
  updateCurrentDateTime();
  setInterval(updateCurrentDateTime, 60000);
  
  // --- Toast Notification System ---
  function showToast(message, type = 'info', duration = 3000) {
    let container = $('#toast-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'toast-container';
      document.body.appendChild(container);
    }
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    container.appendChild(toast);
    
    const removeToast = () => {
        toast.style.animation = 'slideOutRight 0.3s ease forwards';
        toast.addEventListener('animationend', () => toast.remove());
        setTimeout(() => { if (toast.parentNode) toast.remove(); }, 500);
    };
    
    const timer = setTimeout(removeToast, duration);
    
    toast.addEventListener('click', () => {
        clearTimeout(timer);
        removeToast();
    });
  }
  
  // Add CSS for slide out animation
  const styleSheet = document.createElement("style");
  styleSheet.type = "text/css";
  styleSheet.innerText = `@keyframes slideOutRight { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }`;
  document.head.appendChild(styleSheet);
  
  function updateConnectionStatus() {
    const statusEl = $("#connection-status");
    const dotEl = statusEl.querySelector('.status-dot');

    if (!state.firebaseUser) {
      statusEl.className = 'connection-status disconnected';
      dotEl.className = 'status-dot disconnected';
      statusEl.querySelector('span').textContent = 'Not signed in';
      $("#syncAllBtn").disabled = true;
    } else if (state.firestoreHasPendingWrites) {
      statusEl.className = 'connection-status connected';
      dotEl.className = 'status-dot connected';
      dotEl.style.background = 'var(--warning)';
      statusEl.querySelector('span').textContent = 'Syncing...';
      $("#syncAllBtn").disabled = false;
    } else if (state.firestoreConnected) {
      statusEl.className = 'connection-status connected';
      dotEl.className = 'status-dot connected';
      dotEl.style.background = '';
      statusEl.querySelector('span').textContent = 'Synced';
      $("#syncAllBtn").disabled = false;
    } else {
      statusEl.className = 'connection-status disconnected';
      dotEl.className = 'status-dot disconnected';
      dotEl.style.background = 'var(--warning)';
      statusEl.querySelector('span').textContent = 'Offline (cached)';
      $("#syncAllBtn").disabled = false;
    }
    updateDashboardStatus();
  }
  // --- Class Management ---
  function createClass(date, time, playlist = null, attendees = new Set(), notes = '', status = 'draft', classType = '') {
    return {
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      date: date,
      time: normalizeTime(time),
      playlist: playlist,
      attendees: new Set(attendees),
      status: status,
      notes: notes,
      classType: classType || ''
    };
  }
  function getRecommenderClassEntries() {
    return Array.from(state.weeklyPlan.entries())
      .map(([key, cls]) => ({ key, cls }))
      .sort((a, b) => a.key.localeCompare(b.key));
  }
  function getSelectedRecommenderClassEntries() {
    const entries = getRecommenderClassEntries();
    if (entries.length === 0) {
      state.selectedRecommendationClassKeys.clear();
      return [];
    }
    // If no explicit selection, auto-select the next upcoming draft
    if (state.selectedRecommendationClassKeys.size === 0) {
      const now = new Date();
      const nowKey = createDateTimeKey(
        formatDateKey(now),
        normalizeTime(`${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`)
      );
      const nextDraft = entries.find(entry => entry.cls.status !== 'finalized' && entry.key >= nowKey)
        || entries.find(entry => entry.cls.status !== 'finalized');
      if (nextDraft) {
        state.selectedRecommendationClassKeys.add(nextDraft.key);
      }
    }
    // Remove keys that no longer exist in the plan
    const validKeys = new Set(entries.map(e => e.key));
    for (const key of state.selectedRecommendationClassKeys) {
      if (!validKeys.has(key)) state.selectedRecommendationClassKeys.delete(key);
    }
    return entries.filter(e => state.selectedRecommendationClassKeys.has(e.key));
  }
  // Backward-compat shim: returns first selected entry (used by previewRosterBtn etc.)
  function getSelectedRecommenderClassEntry() {
    const selected = getSelectedRecommenderClassEntries();
    return selected.length > 0 ? selected[0] : null;
  }
  function formatRecommenderClassOption(entry) {
    const cls = entry.cls || {};
    const attendeeCount = cls.attendees instanceof Set ? cls.attendees.size : (cls.attendees || []).length;
    const classType = (cls.classType || '').trim() || 'All Types';
    const status = cls.status === 'finalized' ? 'finalized' : 'draft';
    return `${formatDate(cls.date)} ${formatTime(cls.time)} \u2022 ${classType} \u2022 ${attendeeCount} guest${attendeeCount !== 1 ? 's' : ''} \u2022 ${status}`;
  }
  function populatePlannedClassList() {
    const container = $('#plannedClassList');
    if (!container) return;
    const entries = getRecommenderClassEntries();
    container.innerHTML = '';
    if (entries.length === 0) {
      container.innerHTML = '<div style="padding:12px; color:rgba(255,255,255,.5); font-size:13px;">No planned classes. Add classes in Weekly Planner.</div>';
      return;
    }
    entries.forEach(entry => {
      const isChecked = state.selectedRecommendationClassKeys.has(entry.key);
      const item = document.createElement('label');
      item.className = `class-picker-item${isChecked ? ' checked' : ''}`;
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = isChecked;
      checkbox.value = entry.key;
      const label = document.createElement('span');
      label.className = 'class-picker-label';
      label.textContent = formatRecommenderClassOption(entry);
      item.appendChild(checkbox);
      item.appendChild(label);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          state.selectedRecommendationClassKeys.add(entry.key);
        } else {
          state.selectedRecommendationClassKeys.delete(entry.key);
        }
        item.classList.toggle('checked', checkbox.checked);
        refreshRecommenderFromSelection();
      });
      container.appendChild(item);
    });
  }
  function refreshRecommenderFromSelection() {
    const selectedEntries = getSelectedRecommenderClassEntries();
    const metrics = getMetricsForSelectedClasses(selectedEntries);
    refreshDashboard(metrics, selectedEntries);
    updateDashboardStatus(selectedEntries);
  }
  function getMetricsForSelectedClasses(selectedEntries) {
    if (!selectedEntries || selectedEntries.length === 0) return [];
    // Merge attendees from all selected classes
    const mergedAttendees = new Set();
    selectedEntries.forEach(entry => {
      const cls = entry.cls || {};
      const att = cls.attendees instanceof Set ? cls.attendees : new Set(cls.attendees || []);
      att.forEach(g => mergedAttendees.add(g));
    });
    if (mergedAttendees.size === 0) return [];
    // Determine class type filter: use shared type if all match, else no filter
    const classTypes = selectedEntries.map(e => (e.cls.classType || '').trim()).filter(Boolean);
    const uniqueTypes = new Set(classTypes.map(t => t.toLowerCase()));
    const classType = uniqueTypes.size === 1 ? classTypes[0] : '';
    // Use earliest date as reference
    const dates = selectedEntries.map(e => e.cls.date).filter(Boolean).sort();
    const refDate = dates[0] || formatDateKey(new Date());
    return computeMetrics({
      attendees: mergedAttendees,
      classType,
      window: state.selectedWindow,
      date: refDate
    });
  }
  async function assignPlaylistToSelectedClasses(playlistId) {
    const selectedEntries = getSelectedRecommenderClassEntries();
    if (selectedEntries.length === 0) {
      showToast('Select at least one planned class first.', 'error');
      return;
    }
    const normalizedPlaylist = normalizePlaylistId(playlistId);
    if (!normalizedPlaylist) {
      showToast('Playlist format is invalid.', 'error');
      return;
    }
    const draftEntries = selectedEntries.filter(e => e.cls.status !== 'finalized');
    if (draftEntries.length === 0) {
      showToast('All selected classes are finalized.', 'info');
      return;
    }
    let savedCount = 0;
    for (const { key, cls } of draftEntries) {
      const updatedClass = {
        ...cls,
        playlist: normalizedPlaylist,
        attendees: cls.attendees instanceof Set ? new Set(cls.attendees) : new Set(cls.attendees || [])
      };
      if (state.firebaseUser) {
        const saved = await saveClassToFirestore(key, updatedClass);
        if (saved) {
          state.weeklyPlan.set(key, updatedClass);
          savedCount++;
        }
      } else {
        state.weeklyPlan.set(key, updatedClass);
        savedCount++;
      }
      // Sync modal if open on this class
      if (state.selectedClass && createDateTimeKey(state.selectedClass.date, state.selectedClass.time) === key) {
        state.selectedClass = updatedClass;
        const modalPlaylistInput = $('#modal-class-playlist');
        if (modalPlaylistInput) modalPlaylistInput.value = normalizedPlaylist;
        updateModalPlaylistDisplay(normalizedPlaylist);
      }
    }
    if (!state.firebaseUser) saveStateToLocalStorage();
    renderWeeklyCalendar();
    const label = savedCount === 1 ? '1 class' : `${savedCount} classes`;
    showToast(`Playlist #${normalizedPlaylist} assigned to ${label}`, 'success');
    refreshAll();
  }
  function updateDashboardStatus(selectedEntries = getSelectedRecommenderClassEntries()) {
    const selectedClassPill = $("#selectedClassPill");
    const selectedClassTypePill = $("#selectedClassTypePill");
    const selectedPlaylistPill = $("#selectedPlaylistPill");
    if (!selectedClassPill || !selectedClassTypePill || !selectedPlaylistPill) return;
    if (!selectedEntries || selectedEntries.length === 0) {
      selectedClassPill.textContent = 'No classes selected';
      selectedClassTypePill.textContent = 'Class type: --';
      selectedPlaylistPill.textContent = 'Assigned playlist: --';
      return;
    }
    // Aggregate info
    const mergedAttendees = new Set();
    const playlists = new Set();
    const classTypes = new Set();
    let allFinalized = true;
    selectedEntries.forEach(entry => {
      const cls = entry.cls || {};
      const att = cls.attendees instanceof Set ? cls.attendees : new Set(cls.attendees || []);
      att.forEach(g => mergedAttendees.add(g));
      if (cls.playlist) playlists.add(cls.playlist);
      if ((cls.classType || '').trim()) classTypes.add((cls.classType || '').trim());
      if (cls.status !== 'finalized') allFinalized = false;
    });
    const count = selectedEntries.length;
    const guestCount = mergedAttendees.size;
    if (count === 1) {
      const cls = selectedEntries[0].cls || {};
      selectedClassPill.textContent = `${formatDate(cls.date)} ${formatTime(cls.time)} \u2022 ${guestCount} guest${guestCount !== 1 ? 's' : ''} \u2022 ${cls.status || 'draft'}`;
    } else {
      selectedClassPill.textContent = `${count} classes selected \u2022 ${guestCount} unique guest${guestCount !== 1 ? 's' : ''}`;
    }
    selectedClassTypePill.textContent = classTypes.size === 1 ? `Class type: ${[...classTypes][0]}` : classTypes.size > 1 ? `Class types: ${[...classTypes].join(', ')}` : 'Class type: All Types';
    selectedPlaylistPill.textContent = playlists.size === 1 ? `Assigned playlist: #${[...playlists][0]}` : playlists.size > 1 ? `Assigned playlists: ${[...playlists].map(p => '#' + p).join(', ')}` : 'Assigned playlist: --';
  }
  function updateRecordsPill() {
    $("#recordsCountPill").textContent = `${state.records.length} records`;
  }
  // --- Weekly Calendar ---
  function renderWeeklyCalendar() {
    const calendarGrid = $("#calendarGrid");
    const weekDays = getWeekDays(state.currentWeekStart);
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    
    calendarGrid.innerHTML = '';
    
    weekDays.forEach((day, index) => {
      const dayKey = formatDateKey(day);
      const isToday = dayKey === formatDateKey(new Date());
      
      const dayClasses = Array.from(state.weeklyPlan.entries())
        .filter(([key]) => key.startsWith(dayKey))
        .map(([key, cls]) => ({...cls, dateTimeKey: key}))
        .sort((a, b) => a.time.localeCompare(b.time));
      
      const dayCard = document.createElement('div');
      dayCard.className = `day-card${isToday ? ' today' : ''}${dayClasses.length > 0 ? ' has-classes' : ''}`;
      
      let classesHTML = '';
      if (dayClasses.length > 0) {
        classesHTML = dayClasses.map(cls => `
          <div class="class-item" onclick="openClassModal('${cls.dateTimeKey}')">
            <div class="class-time">${formatTime(cls.time)}</div>
            <div class="class-info">
              ${cls.classType ? esc(cls.classType) + ' ‚Ä¢ ' : ''}${cls.playlist ? `Playlist #${esc(cls.playlist)}` : 'No playlist assigned'} ‚Ä¢ ${cls.attendees.size} guests
            </div>
            ${cls.playlist ? renderPlaylistTags(cls.playlist, { compact: true }) : ''}
            <div class="pill ${cls.status === 'draft' ? 'status-draft' : 'status-finalized'} " style="margin-top: 4px; font-size: 11px; padding: 4px 8px;">
              ${cls.status}
            </div>
          </div>
        `).join('');
      } else {
        classesHTML = '<div class="empty-state" style="padding: 20px 0;"><p style="margin:0;">No classes scheduled</p></div>';
      }
      
      dayCard.innerHTML = `
        <div class="day-header">
          <div class="day-name">${dayNames[index]}${isToday ? ' <span style="color:var(--info); font-size:12px; font-weight:600; margin-left:4px;">TODAY</span>' : ''}</div>
          <div class="day-date">${day.getMonth() + 1}/${day.getDate()}</div>
        </div>
        <div class="class-list">${classesHTML}</div>
        <div class="class-actions">
          <button class="btn btn-sm btn-primary" onclick="openNewClassModal('${dayKey}')">+ Add Class</button>
        </div>
      `;
      
      calendarGrid.appendChild(dayCard);
    });
    
    updateWeeklyStats();
  }
  function updateWeeklyStats() {
    const weekStart = state.currentWeekStart;
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);
    
    $("#weekRangePill").textContent = `${formatDate(weekStart)} - ${formatDate(weekEnd)}`;
    
    let drafts = 0, finalized = 0;
    state.weeklyPlan.forEach(cls => {
        const clsDate = parseDateInput(cls.date);
        if (clsDate >= weekStart && clsDate <= weekEnd) {
            if (cls.status === 'draft') drafts++;
            else finalized++;
        }
    });
    
    $("#draftsCountPill").textContent = `${drafts} draft${drafts !== 1 ? 's' : ''}`;
    $("#finalizedCountPill").textContent = `${finalized} finalized`;
  }
  function navigateWeek(direction) {
    if (direction === 0) {
        state.currentWeekStart = getWeekStart(new Date());
    } else {
        const newStart = new Date(state.currentWeekStart);
        newStart.setDate(newStart.getDate() + (direction * 7));
        state.currentWeekStart = newStart;
    }
    renderWeeklyCalendar();
  }
  
  window.openNewClassModal = function(dateKey) {
    state.selectedClass = createClass(dateKey, '09:00');
    state.modalAttendees = new Set();

    $("#class-modal-title").textContent = 'Plan New Class';
    $("#modal-class-date").value = dateKey;
    populateTimeSelect($("#modal-class-time"), '09:00');
    populateClassTypeDropdown($("#modal-class-type"), '');
    $("#modal-class-playlist").value = '';
    updateModalPlaylistDisplay('');
    $("#modal-class-notes").value = '';

    populateModalGuestList();
    renderModalSelectedGuests();

    $("#delete-class-modal").classList.add('hidden');
    $("#class-modal").classList.remove('hidden');
  };
  window.openClassModal = function(dateTimeKey) {
    const classData = state.weeklyPlan.get(dateTimeKey);
    if (!classData) return;

    state.selectedClass = classData;
    state.modalAttendees = new Set(classData.attendees);

    $("#class-modal-title").textContent = 'Edit Class';
    $("#modal-class-date").value = classData.date;
    populateTimeSelect($("#modal-class-time"), classData.time || '09:00');
    populateClassTypeDropdown($("#modal-class-type"), classData.classType || '');
    $("#modal-class-notes").value = classData.notes || '';
    $("#modal-class-playlist").value = classData.playlist || '';
    updateModalPlaylistDisplay(classData.playlist || '');
    populateModalGuestList();
    renderModalSelectedGuests();

    $("#delete-class-modal").classList.remove('hidden');
    $("#class-modal").classList.remove('hidden');
  };
  function updateModalPlaylistDisplay(playlistId) {
    const display = $('#modal-class-playlist-display');
    if (!display) return;
    const normalized = normalizePlaylistId(playlistId);
    display.textContent = normalized ? `Playlist #${normalized}` : 'No playlist assigned yet';
  }
  // --- Guest Selection System ---
  function populateModalGuestList() {
    const modalGuestList = $("#modal-guest-list");
    modalGuestList.innerHTML = "";
    
    Array.from(state.allGuests).sort().forEach(guest => {
      const guestElement = document.createElement("div");
      guestElement.className = `guest-list-item ${state.modalAttendees.has(guest) ? 'selected' : ''}`;
      guestElement.dataset.guest = guest;
      guestElement.textContent = guest;

      guestElement.addEventListener("click", () => {
        if (state.modalAttendees.has(guest)) {
          state.modalAttendees.delete(guest);
        } else {
          state.modalAttendees.add(guest);
        }
        renderModalSelectedGuests();
        updateModalGuestListSelection();
        // Clear search, show all guests, refocus for next search
        const searchInput = $('#modal-guest-search');
        const clearBtn = $('#modal-guest-search-clear');
        searchInput.value = '';
        if (clearBtn) clearBtn.classList.remove('visible');
        $$("#modal-guest-list .guest-list-item").forEach(i => i.style.display = '');
        searchInput.focus();
      });
      modalGuestList.appendChild(guestElement);
    });
  }
  function renderModalSelectedGuests() {
    const container = $("#modal-selected-guests");
    container.innerHTML = "";
    
    if (state.modalAttendees.size === 0) {
      container.innerHTML = `<div class="no-selection">No guests selected</div>`;
    } else {
      [...state.modalAttendees].sort().forEach(name => {
        const guestChip = document.createElement("div");
        guestChip.className = "selected-guest-item";
        guestChip.innerHTML = `<span>${esc(name)}</span><span class="remove-guest" data-guest="${esc(name)}">‚úï</span>`;
        guestChip.querySelector(".remove-guest").addEventListener("click", (e) => {
          e.stopPropagation();
          state.modalAttendees.delete(name);
          renderModalSelectedGuests();
          updateModalGuestListSelection();
        });
        container.appendChild(guestChip);
      });
    }
  }
  function updateModalGuestListSelection() {
    $$("#modal-guest-list .guest-list-item").forEach(item => {
      item.classList.toggle("selected", state.modalAttendees.has(item.dataset.guest));
    });
  }
  
  // --- Metrics Calculation ---
  function lastHeardMap(referenceDate) {
    const refDate = parseDateInput(referenceDate || formatDateKey(new Date())) || new Date();
    const map = new Map();
    state.records.forEach(r => {
      const recordDate = parseDateInput(r.date);
      if (!recordDate || recordDate > refDate) return;
      if (!map.has(r.guest)) map.set(r.guest, new Map());
      const pm = map.get(r.guest);
      const prev = pm.get(r.playlist);
      if (!prev || recordDate > parseDateInput(prev)) {
        pm.set(r.playlist, r.date);
      }
    });
    return map;
  }
  function computeMetrics(opts = {}) {
    const refDateISO = opts.date || formatDateKey(new Date());
    const lm = lastHeardMap(refDateISO);
    const rosterSource = opts.attendees instanceof Set ? Array.from(opts.attendees) : Array.from(opts.attendees || []);
    const roster = rosterSource.filter(Boolean);
    if (roster.length === 0) return [];
    const windowDays = Number.isFinite(opts.window) ? opts.window : state.selectedWindow;
    const classTypeFilter = opts.classType !== undefined ? opts.classType : '';
    const classTypeFilterLower = classTypeFilter.toLowerCase();
    const filteredPlaylists = state.playlists.filter(pl => {
      const status = normalizePlaylistStatus(state.playlistStatus.get(pl) || 'Active');
      if (status === 'Retired' || status === 'Removed') return false;
      if (classTypeFilterLower) {
        const tags = state.playlistTags.get(pl) || [];
        return tags.some(t => t.toLowerCase() === classTypeFilterLower);
      }
      return true;
    });
    const byPlaylist = filteredPlaylists.map(pl => {
      let never = 0;
      let deltas = [];
      let dueCount = 0;
      let recentCount = 0;
      roster.forEach(g => {
        const last = lm.get(g)?.get(pl);
        if (!last) {
          never++;
          return;
        } else {
          const d = daysBetween(refDateISO, last);
          if (d < 0) {
            never++;
            return;
          }
          deltas.push(d);
          if (d >= windowDays) {
            dueCount++;
          } else {
            recentCount++;
          }
        }
      });
      const medianDays = deltas.length ? median(deltas) : 0;
      const rosterSize = roster.length;
      const neverPct = rosterSize ? Math.round((never / rosterSize) * 100) : 0;
      const duePct = rosterSize ? Math.round((dueCount / rosterSize) * 100) : 0;
      const recentPct = rosterSize ? Math.round((recentCount / rosterSize) * 100) : 0;
      // Favor never-heard and replay-ready coverage while penalizing recently-heard overlap.
      const score = (neverPct * 3.4) + (duePct * 2.2) + (medianDays * 0.12) - (recentPct * 2.6);

      return {
        playlist: pl,
        never,
        dueCount,
        recentCount,
        heardCount: deltas.length,
        median: medianDays,
        stalePct: duePct, // Backward compatible alias
        readyPct: duePct,
        neverPct,
        recentPct,
        rosterSize,
        score
      };
    });
    byPlaylist.sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      if (b.neverPct !== a.neverPct) return b.neverPct - a.neverPct;
      if (b.readyPct !== a.readyPct) return b.readyPct - a.readyPct;
      if (b.median !== a.median) return b.median - a.median;
      return comparePlaylistIds(a.playlist, b.playlist);
    });
    return byPlaylist;
  }
  function getRecommendationStrength(metrics) {
    const best = metrics[0];
    if (!best) return null;
    const second = metrics[1];
    if (!second) {
      return {
        tone: 'strong',
        label: 'High confidence',
        detail: 'Only one active playlist matches current filters.',
        gap: null
      };
    }
    const gap = Math.max(0, best.score - second.score);
    const roundedGap = Math.round(gap * 10) / 10;
    if (gap >= 18) {
      return {
        tone: 'strong',
        label: 'High confidence',
        detail: `${roundedGap} points ahead of #${second.playlist}.`,
        gap: roundedGap
      };
    }
    if (gap >= 8) {
      return {
        tone: 'moderate',
        label: 'Medium confidence',
        detail: `${roundedGap} points ahead of #${second.playlist}.`,
        gap: roundedGap
      };
    }
    return {
      tone: 'close',
      label: 'Close decision',
      detail: `${roundedGap} points ahead of #${second.playlist}. Check runner-ups.`,
      gap: roundedGap
    };
  }
  // --- UI Refresh Functions ---
  function refreshAll() {
      const selectedEntries = getSelectedRecommenderClassEntries();
      populatePlannedClassList();
      const metrics = getMetricsForSelectedClasses(selectedEntries);
      refreshDashboard(metrics, selectedEntries);
      refreshExplorer();
      updateDashboardStatus(selectedEntries);
  }
  function refreshDashboard(metrics, selectedEntries = getSelectedRecommenderClassEntries()) {
    const best = metrics[0];
    const bestSummary = $("#bestSummary");
    const bestStrength = $("#bestStrength");
    const rankingsBody = $("#runnerUps");
    if (!bestSummary || !bestStrength || !rankingsBody) return;
    const assignBestBtn = $("#assignBestPlaylistBtn");
    if (assignBestBtn) {
      assignBestBtn.disabled = true;
      assignBestBtn.dataset.playlist = '';
      assignBestBtn.textContent = 'Assign Best Playlist';
    }

    if (!selectedEntries || selectedEntries.length === 0) {
      bestSummary.innerHTML = '<div class="muted">Add a class in Weekly Planner, then select it here for recommendations.</div>';
      bestStrength.innerHTML = '';
      $("#bestNever").textContent = "--";
      $("#bestMedian").textContent = "--";
      $("#bestReady").textContent = "--";
      rankingsBody.innerHTML = '<tr><td colspan="8" style="text-align:center; color:rgba(255,255,255,.6);">No planned classes available.</td></tr>';
      return;
    }

    // Compute aggregate roster size
    const mergedAttendees = new Set();
    selectedEntries.forEach(entry => {
      const cls = entry.cls || {};
      const att = cls.attendees instanceof Set ? cls.attendees : new Set(cls.attendees || []);
      att.forEach(g => mergedAttendees.add(g));
    });
    const rosterSize = mergedAttendees.size;
    const classTypes = [...new Set(selectedEntries.map(e => (e.cls.classType || '').trim()).filter(Boolean))];
    const classType = classTypes.length === 1 ? classTypes[0] : '';
    const classCount = selectedEntries.length;
    const draftEntries = selectedEntries.filter(e => e.cls.status !== 'finalized');
    const allFinalized = draftEntries.length === 0;

    // Check if best playlist is already assigned to ALL selected draft classes
    const assignedPlaylists = new Set(selectedEntries.map(e => normalizePlaylistId(e.cls.playlist)).filter(Boolean));

    if (!best || rosterSize === 0) {
      bestSummary.innerHTML = rosterSize === 0
        ? '<div class="muted">Selected classes have no attendees yet. Add attendees in Weekly Planner.</div>'
        : (classType
          ? `<div class="muted">No playlists tagged for <strong>${esc(classType)}</strong>. Tag playlists in the Playlist Manager or update class type.</div>`
          : '<div class="muted">No active playlists are available for ranking.</div>');
      bestStrength.innerHTML = '';
      $("#bestNever").textContent = "--";
      $("#bestMedian").textContent = "--";
      $("#bestReady").textContent = "--";
      rankingsBody.innerHTML = rosterSize === 0
        ? '<tr><td colspan="8" style="text-align:center; color:rgba(255,255,255,.6);">No ranking yet ‚Äî selected classes have no attendees.</td></tr>'
        : '<tr><td colspan="8" style="text-align:center; color:rgba(255,255,255,.6);">No playlists match the selected class type.</td></tr>';
      return;
    }

    const strength = getRecommendationStrength(metrics);
    const selectionLabel = classCount === 1
      ? `Selected class: ${esc(formatDateTime(selectedEntries[0].cls.date, selectedEntries[0].cls.time))} \u2022 ${rosterSize} attendees`
      : `${classCount} classes selected \u2022 ${rosterSize} unique attendees`;
    const assignedText = assignedPlaylists.size === 1 ? `#${esc([...assignedPlaylists][0])}` : assignedPlaylists.size > 1 ? 'Mixed' : 'None';
    bestSummary.innerHTML = `
      <div class="best-summary-title">
        Playlist <span style="color: var(--accent);">#${best.playlist}</span>${renderPlaylistTags(best.playlist)}
      </div>
      <div class="best-summary-meta">${selectionLabel}</div>
      <div class="best-summary-meta">Replay-ready threshold: ${state.selectedWindow} days${classType ? ' \u2022 ' + esc(classType) : ''} \u2022 Current assignment: ${assignedText}</div>
      <div class="best-insight-list">
        <div class="best-insight"><b>${best.never}</b><span>attendees have never heard this playlist</span></div>
        <div class="best-insight"><b>${best.dueCount}</b><span>attendees are replay-ready (&ge; ${state.selectedWindow} days)</span></div>
        <div class="best-insight"><b>${best.recentCount}</b><span>attendees heard it recently (&lt; ${state.selectedWindow} days)</span></div>
      </div>
    `;
    bestStrength.innerHTML = strength
      ? `<span class="rec-strength-pill ${strength.tone}">${esc(strength.label)}</span><span class="subtle" style="font-size:13px;">${esc(strength.detail)}</span>`
      : '';

    $("#bestNever").textContent = `${best.never} (${best.neverPct}%)`;
    $("#bestMedian").textContent = `${best.median}d`;
    $("#bestReady").textContent = `${best.readyPct}%`;

    if (assignBestBtn) {
      assignBestBtn.dataset.playlist = best.playlist;
      const allAlreadyAssigned = draftEntries.length > 0 && draftEntries.every(e => normalizePlaylistId(e.cls.playlist) === best.playlist);
      assignBestBtn.disabled = allFinalized || allAlreadyAssigned;
      if (allFinalized) {
        assignBestBtn.textContent = classCount === 1 ? 'Class Finalized' : 'All Classes Finalized';
      } else if (allAlreadyAssigned) {
        assignBestBtn.textContent = `Best Already Assigned (#${best.playlist})`;
      } else {
        const assignLabel = classCount === 1 ? `Assign Best (#${best.playlist})` : `Assign Best (#${best.playlist}) to ${draftEntries.length} class${draftEntries.length !== 1 ? 'es' : ''}`;
        assignBestBtn.textContent = assignLabel;
      }
    }

    rankingsBody.innerHTML = metrics.map((row, index) => {
      const allRowAssigned = draftEntries.length > 0 && draftEntries.every(e => normalizePlaylistId(e.cls.playlist) === row.playlist);
      const scoreLabel = (Math.round(row.score * 10) / 10).toFixed(1);
      const actionHTML = allFinalized
        ? '<span class="pill status-finalized" style="font-size:11px; padding:4px 8px;">Finalized</span>'
        : `<button type="button" class="btn btn-sm"${allRowAssigned ? ' disabled' : ''} data-assign-playlist="${esc(row.playlist)}">${allRowAssigned ? 'Assigned' : 'Assign'}</button>`;
      return `
        <tr${allRowAssigned ? ' class="rank-row-assigned"' : ''}>
          <td>${index + 1}</td>
          <td><strong>#${esc(row.playlist)}</strong>${renderPlaylistTags(row.playlist, { compact: true })}</td>
          <td>${row.never}/${row.rosterSize} (${row.neverPct}%)</td>
          <td>${row.dueCount}/${row.rosterSize} (${row.readyPct}%)</td>
          <td>${row.median}d</td>
          <td>${row.recentCount}/${row.rosterSize} (${row.recentPct}%)</td>
          <td><span class="rank-score">${scoreLabel}</span></td>
          <td>${actionHTML}</td>
        </tr>
      `;
    }).join('');
  }
  function refreshExplorer() {
    const tbody = $("#explorerTbody");
    tbody.innerHTML = "";
    const { column, ascending } = state.explorerSortOrder;

    // Build playlist data array for sorting
    const rows = state.playlists.map(pl => {
      const status = state.playlistStatus.get(pl) || 'Active';
      return { playlist: pl, status };
    });

    rows.sort((a, b) => {
      if (column === 'playlist') {
        const cmp = comparePlaylistIds(a.playlist, b.playlist);
        return ascending ? cmp : -cmp;
      }
      if (column === 'status') {
        const cmp = a.status.localeCompare(b.status);
        return ascending ? cmp : -cmp;
      }
      return 0;
    });

    rows.forEach(row => {
      const pl = row.playlist;
      const status = row.status;
      const tags = state.playlistTags.get(pl) || [];
      const isRetired = status === 'Retired';
      const tr = document.createElement('tr');
      tr.className = 'explorer-row' + (isRetired ? ' retired-row' : '');

      // Playlist name cell
      const tdName = document.createElement('td');
      tdName.dataset.label = 'Playlist';
      tdName.innerHTML = `<strong>Playlist #${esc(pl)}</strong>`;

      // Tags cell
      const tdTags = document.createElement('td');
      tdTags.dataset.label = 'Tags';
      const tagsDiv = document.createElement('div');
      tagsDiv.className = 'manager-tags-cell';
      tags.forEach(t => {
        const chip = document.createElement('span');
        chip.className = 'tag-chip-removable';
        chip.dataset.tag = t;
        chip.innerHTML = `<span>${esc(t)}</span><span class="remove-tag">‚úï</span>`;
        chip.querySelector('.remove-tag').addEventListener('click', e => {
          e.stopPropagation();
          removePlaylistTag(pl, t);
        });
        tagsDiv.appendChild(chip);
      });
      const addTagBtn = document.createElement('span');
      addTagBtn.className = 'add-tag-btn';
      addTagBtn.textContent = '+';
      addTagBtn.title = 'Add tag';
      addTagBtn.addEventListener('click', e => {
        e.stopPropagation();
        if (state.expandedPlaylist === pl) {
          state.expandedPlaylist = null;
        } else {
          state.expandedPlaylist = pl;
        }
        refreshExplorer();
      });
      tagsDiv.appendChild(addTagBtn);
      tdTags.appendChild(tagsDiv);

      // Status cell
      const tdStatus = document.createElement('td');
      tdStatus.dataset.label = 'Status';
      const statusPill = document.createElement('span');
      statusPill.className = 'status-toggle ' + (isRetired ? 'retired' : 'active');
      statusPill.textContent = status;
      statusPill.addEventListener('click', e => {
        e.stopPropagation();
        setPlaylistStatus(pl, isRetired ? 'Active' : 'Retired');
      });
      tdStatus.appendChild(statusPill);

      // Actions cell
      const tdActions = document.createElement('td');
      tdActions.dataset.label = 'Actions';
      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn-remove-playlist';
      removeBtn.textContent = 'Remove';
      removeBtn.addEventListener('click', e => {
        e.stopPropagation();
        removePlaylist(pl);
      });
      tdActions.appendChild(removeBtn);

      tr.appendChild(tdName);
      tr.appendChild(tdTags);
      tr.appendChild(tdStatus);
      tr.appendChild(tdActions);
      tbody.appendChild(tr);

      // Expanded tag editor row
      if (state.expandedPlaylist === pl) {
        const editorTr = document.createElement('tr');
        editorTr.className = 'tag-editor-row';
        editorTr.innerHTML = `<td colspan="4">${buildTagEditorHTML(pl)}</td>`;
        editorTr.addEventListener('click', e => e.stopPropagation());
        tbody.appendChild(editorTr);
        wireTagEditor(pl, editorTr);
      }
    });
  }
  function buildTagEditorHTML(playlistNum) {
    const tags = state.playlistTags.get(playlistNum) || [];
    const chips = tags.map(t =>
      `<span class="tag-chip-removable" data-tag="${esc(t)}"><span>${esc(t)}</span><span class="remove-tag">‚úï</span></span>`
    ).join('');
    const currentTags = new Set(tags.map(t => t.toLowerCase()));
    const available = getAllClassTypes().filter(t => !currentTags.has(t.toLowerCase()));
    const options = available.map(t => `<option value="${esc(t)}">${esc(t)}</option>`).join('');
    return `<div class="tag-editor">
      <div style="font-weight:600; font-size:13px; color:rgba(255,255,255,.7);">Class Types for Playlist #${playlistNum}</div>
      <div class="tag-editor-chips">${chips || '<span style="color:rgba(255,255,255,.4); font-size:13px;">No tags yet</span>'}</div>
      <select class="tag-select select" style="margin-top:6px;">
        <option value="" disabled selected>Add class type...</option>
        ${options}
      </select>
    </div>`;
  }
  function wireTagEditor(playlistNum, editorTr) {
    // Remove buttons
    editorTr.querySelectorAll('.remove-tag').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const tag = btn.closest('.tag-chip-removable').dataset.tag;
        removePlaylistTag(playlistNum, tag);
      });
    });

    // Dropdown select
    const select = editorTr.querySelector('.tag-select');
    if (select) {
      select.addEventListener('change', () => {
        const value = select.value;
        if (value) {
          addPlaylistTag(playlistNum, value);
        }
      });
    }
  }
  function refreshHistory() {
    const tbody = $("#historyTbody");
    const searchTerm = $("#history-search").value.toLowerCase();
    
    const byClass = new Map();
    [...state.records, ...Array.from(state.weeklyPlan.values()).filter(c => c.status === 'finalized')]
    .forEach(r => {
        if (!r.playlist) return;
        const normalizedTime = normalizeTime(r.time, '00:00');
        const classNumber = normalizeClassNumber(r.classNumber);
        const key = classNumber
          ? `${r.date}T${normalizedTime}::${r.playlist}::${classNumber}`
          : `${r.date}T${normalizedTime}::${r.playlist}`;
        if (!byClass.has(key)) {
            byClass.set(key, { date: r.date, time: normalizedTime, playlist: r.playlist, classType: r.classType || '', classNumber, guests: new Set(), status: 'finalized' });
        }
        const entry = byClass.get(key);
        if (!entry.classType && r.classType) entry.classType = r.classType;
        if (!entry.classNumber && classNumber) entry.classNumber = classNumber;
        if (r.guest) {
            entry.guests.add(r.guest);
        } else if (r.attendees) {
            r.attendees.forEach(g => entry.guests.add(g));
        }
    });

    let rows = [...byClass.values()].filter(row => {
        if (!searchTerm) return true;
        const guestNames = [...row.guests].join(' ').toLowerCase();
        const classType = (row.classType || '').toLowerCase();
        const classNumber = (row.classNumber || '').toLowerCase();
        return row.date.includes(searchTerm) || row.playlist.toString().includes(searchTerm) || classType.includes(searchTerm) || classNumber.includes(searchTerm) || guestNames.includes(searchTerm);
    });
    
    const { column, ascending } = state.sortOrder;
    rows.sort((a, b) => {
        let aVal, bVal;
        if (column === 'datetime') {
            aVal = new Date(`${a.date}T${a.time}`);
            bVal = new Date(`${b.date}T${b.time}`);
        } else if (column === 'count') {
            aVal = a.guests.size;
            bVal = b.guests.size;
        } else {
            aVal = a[column];
            bVal = b[column];
        }
        if (aVal < bVal) return ascending ? -1 : 1;
        if (aVal > bVal) return ascending ? 1 : -1;
        return 0;
    });

    // Update history summary stats
    const histStats = $("#history-stats");
    const totalClasses = rows.length;
    const uniquePlaylists = new Set(rows.map(r => r.playlist)).size;
    const uniqueGuests = new Set(rows.flatMap(r => [...r.guests])).size;
    histStats.innerHTML = `
      <div class="stat-item"><span class="stat-value">${totalClasses}</span> classes</div>
      <div class="stat-item"><span class="stat-value">${uniquePlaylists}</span> playlists used</div>
      <div class="stat-item"><span class="stat-value">${uniqueGuests}</span> unique guests</div>
    `;

    tbody.innerHTML = "";
    if (rows.length === 0) {
      tbody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:40px 20px; color:rgba(255,255,255,.6);">No class history yet. Finalize classes from the Weekly Planner to build your history.</td></tr>`;
      return;
    }
    rows.forEach(row => {
      const guestArray = [...row.guests].sort();
      const classTypeText = row.classType ? esc(row.classType) : '<span style="color:rgba(255,255,255,.45);">-</span>';
      const moreCount = guestArray.length - 3;
      const moreText = moreCount > 0
        ? ` <span class="history-expand-guests" style="color:var(--accent); cursor:pointer;" data-guests="${guestArray.map(g => esc(g)).join('|||')}">+${moreCount} more</span>`
        : '';
      const tr = `
        <tr>
          <td data-label="Date & Time">${formatDate(row.date)} ${formatTime(row.time)}</td>
          <td data-label="Class Type">${classTypeText}</td>
          <td data-label="Playlist"><strong>Playlist #${row.playlist}</strong></td>
          <td data-label="Attendees"><span class="pill">${guestArray.length}</span></td>
          <td data-label="Guest Names"><span class="guest-names-short">${guestArray.slice(0, 3).map(g => esc(g)).join(", ")}${moreText}</span><span class="guest-names-full" style="display:none;">${guestArray.map(g => esc(g)).join(", ")} <span class="history-collapse-guests" style="color:var(--accent); cursor:pointer;">show less</span></span></td>
          <td data-label="Status"><span class="pill status-finalized">Completed</span></td>
        </tr>
      `;
      tbody.innerHTML += tr;
    });
    // Expandable guest names
    tbody.querySelectorAll('.history-expand-guests').forEach(el => {
      el.addEventListener('click', (e) => {
        const td = e.target.closest('td');
        td.querySelector('.guest-names-short').style.display = 'none';
        td.querySelector('.guest-names-full').style.display = '';
      });
    });
    tbody.querySelectorAll('.history-collapse-guests').forEach(el => {
      el.addEventListener('click', (e) => {
        const td = e.target.closest('td');
        td.querySelector('.guest-names-short').style.display = '';
        td.querySelector('.guest-names-full').style.display = 'none';
      });
    });
  }
  function refreshGuests() {
    const container = $("#guests-grid");
    const searchTerm = $("#guest-search-filter").value.toLowerCase();
    
    const guestsStatsBar = $("#guests-stats");
    if (state.allGuests.size === 0) {
      guestsStatsBar.innerHTML = '';
      container.innerHTML = `<div class="empty-state"><h3>No guest data available</h3><p>Sign in and import data to see guest profiles</p></div>`;
      return;
    }
    const guestStats = Array.from(state.allGuests)
      .filter(guest => guest.toLowerCase().includes(searchTerm))
      .map(guest => {
        const guestRecords = state.records.filter(r => r.guest === guest);
        const todayKey = formatDateKey(new Date());
        const eligibleRecords = guestRecords.filter(r => r.date <= todayKey);
        const totalClasses = eligibleRecords.length;
        const playlistsHeard = new Set(eligibleRecords.map(r => r.playlist)).size;
        const lastClassDate = eligibleRecords.length > 0 ? eligibleRecords.reduce((latest, r) => r.date > latest ? r.date : latest, '') : null;
        const daysSince = lastClassDate ? daysBetween(formatDateKey(new Date()), lastClassDate) : null;
        return { name: guest, totalClasses, playlistsHeard, daysSince, records: guestRecords };
      })
      .sort((a, b) => (a.daysSince ?? 9999) - (b.daysSince ?? 9999)); // Sort by most recent first
    
    // Update guest summary stats
    const activeGuests = guestStats.filter(g => g.daysSince !== null && g.daysSince <= 90).length;
    guestsStatsBar.innerHTML = `
      <div class="stat-item"><span class="stat-value">${guestStats.length}</span> total guests</div>
      <div class="stat-item"><span class="stat-value">${activeGuests}</span> active (last 90 days)</div>
    `;

    container.innerHTML = "";
    guestStats.forEach(guest => {
      const guestCard = document.createElement("div");
      guestCard.className = "guest-card";
      guestCard.dataset.guestName = guest.name;
      guestCard.innerHTML = `
        <div class="guest-card-header">
          <div class="guest-avatar">${esc(guest.name.split(' ').map(n => n[0]).join('').toUpperCase())}</div>
          <div class="guest-info">
            <h4>${esc(guest.name)}</h4>
            <p>${guest.daysSince !== null ? `Last seen: ${guest.daysSince} days ago` : 'No classes yet'}</p>
          </div>
        </div>
        <div class="guest-stats">
          <div class="guest-stat"><span class="value">${guest.totalClasses}</span><span class="label">Classes</span></div>
          <div class="guest-stat"><span class="value">${guest.playlistsHeard}</span><span class="label">Playlists</span></div>
        </div>`;
      guestCard.addEventListener('click', () => showGuestDetailModal(guest.name));
      container.appendChild(guestCard);
    });
  }
  function showGuestDetailModal(guestName) {
      const guestRecords = state.records
          .filter(r => r.guest === guestName)
          .sort((a, b) => new Date(`${b.date}T${b.time}`) - new Date(`${a.date}T${a.time}`));
      
      $('#guest-modal-title').textContent = `${guestName}'s Profile`;
      
      let contentHTML = `<div class="table-container"><table class="data-table"><thead><tr><th>Date</th><th>Playlist</th></tr></thead><tbody>`;
      if (guestRecords.length > 0) {
          guestRecords.forEach(record => {
              contentHTML += `<tr><td>${formatDateTime(record.date, record.time)}</td><td>Playlist #${record.playlist}</td></tr>`;
          });
      } else {
          contentHTML += `<tr><td colspan="2" style="text-align:center;">No class history found.</td></tr>`;
      }
      contentHTML += `</tbody></table></div>`;
      
      $('#guest-modal-content').innerHTML = contentHTML;
      $('#guest-modal').classList.remove('hidden');
  }

  // --- EVENT LISTENERS ---
  function addEventListeners() {
      // Tab navigation
      $$('.tab-btn').forEach(btn => {
          btn.addEventListener('click', () => {
              const tab = btn.dataset.tab;
              $$('.tab-btn').forEach(b => b.setAttribute('aria-selected', 'false'));
              btn.setAttribute('aria-selected', 'true');
              $$('main > section').forEach(s => s.classList.add('hidden'));
              $(`#${tab}`).classList.remove('hidden');

              // Refresh content on tab switch
              if(tab === 'weekly') renderWeeklyCalendar();
              if(tab === 'dashboard') refreshAll();
              if(tab === 'history') refreshHistory();
              if(tab === 'guests') refreshGuests();
              if(tab === 'explorer') refreshAll();
          });
      });
      // Dashboard controls ‚Äî class picker
      const selectAllDraftsBtn = $('#selectAllDraftsBtn');
      if (selectAllDraftsBtn) {
        selectAllDraftsBtn.addEventListener('click', () => {
          const entries = getRecommenderClassEntries();
          entries.forEach(e => {
            if (e.cls.status !== 'finalized') state.selectedRecommendationClassKeys.add(e.key);
          });
          refreshAll();
        });
      }
      const clearAllClassesBtn = $('#clearAllClassesBtn');
      if (clearAllClassesBtn) {
        clearAllClassesBtn.addEventListener('click', () => {
          state.selectedRecommendationClassKeys.clear();
          refreshAll();
        });
      }
      const playlistWindow = $('#playlistWindow');
      if (playlistWindow) {
        playlistWindow.addEventListener('change', (e) => {
          state.selectedWindow = parseInt(e.target.value, 10);
          refreshAll();
        });
      }
      const assignBestBtn = $('#assignBestPlaylistBtn');
      if (assignBestBtn) {
        assignBestBtn.addEventListener('click', async () => {
          const playlistId = assignBestBtn.dataset.playlist || '';
          if (!playlistId) {
            showToast('No recommendation available to assign.', 'error');
            return;
          }
          await assignPlaylistToSelectedClasses(playlistId);
        });
      }
      const rankingsBody = $('#runnerUps');
      if (rankingsBody) {
        rankingsBody.addEventListener('click', async (e) => {
          const btn = e.target.closest('[data-assign-playlist]');
          if (!btn || btn.disabled) return;
          await assignPlaylistToSelectedClasses(btn.dataset.assignPlaylist || '');
        });
      }
      const previewRosterBtn = $('#previewRosterBtn');
      if (previewRosterBtn) {
        previewRosterBtn.addEventListener('click', () => {
        const selectedEntries = getSelectedRecommenderClassEntries();
        const metrics = getMetricsForSelectedClasses(selectedEntries);
        const best = metrics[0];
        if (selectedEntries.length === 0 || !best) {
          showToast('Select planned classes with attendees to view details.', 'error');
          return;
        }
        // Merge attendees from all selected classes
        const mergedAttendees = new Set();
        selectedEntries.forEach(entry => {
          const cls = entry.cls || {};
          const att = cls.attendees instanceof Set ? cls.attendees : new Set(cls.attendees || []);
          att.forEach(g => mergedAttendees.add(g));
        });
        const roster = [...mergedAttendees].sort();
        if (roster.length === 0) {
          showToast('Add attendees to selected classes first.', 'error');
          return;
        }
        const dates = selectedEntries.map(e => e.cls.date).filter(Boolean).sort();
        const refDate = dates[0] || formatDateKey(new Date());
        const lm = lastHeardMap(refDate);
        const windowDays = state.selectedWindow;
        const neverList = [];
        const readyList = [];
        const recentList = [];
        roster.forEach(g => {
          const last = lm.get(g)?.get(best.playlist);
          if (!last) {
            neverList.push(g);
          } else {
            const d = daysBetween(refDate, last);
            if (d < 0) {
              neverList.push(g);
            } else if (d >= windowDays) {
              readyList.push({ name: g, days: d });
            } else {
              recentList.push({ name: g, days: d });
            }
          }
        });
        readyList.sort((a, b) => b.days - a.days);
        recentList.sort((a, b) => a.days - b.days);
        const classCount = selectedEntries.length;
        const classLabel = classCount === 1
          ? esc(formatDateTime(selectedEntries[0].cls.date, selectedEntries[0].cls.time))
          : `${classCount} classes selected`;
        let html = `<h4 style="margin-bottom:12px;">Playlist #${best.playlist} ‚Äî Roster Breakdown</h4>`;
        html += `<p class="muted" style="margin-bottom:12px;">${classLabel} \u2022 ${roster.length} attendees \u2022 Replay-ready threshold: ${windowDays} days</p>`;
        if (neverList.length > 0) {
          html += `<div style="margin-bottom:12px;"><strong>Never Heard (${neverList.length})</strong><div style="margin-top:4px;">${neverList.map(g => `<span class="pill">${esc(g)}</span>`).join(' ')}</div></div>`;
        }
        if (readyList.length > 0) {
          html += `<div style="margin-bottom:12px;"><strong>Replay-ready (${readyList.length})</strong><div style="margin-top:4px;">${readyList.map(g => `<span class="pill status-draft">${esc(g.name)} \u2014 ${g.days}d ago</span>`).join(' ')}</div></div>`;
        }
        if (recentList.length > 0) {
          html += `<div style="margin-bottom:12px;"><strong>Recently heard (${recentList.length})</strong><div style="margin-top:4px;">${recentList.map(g => `<span class="pill status-finalized">${esc(g.name)} \u2014 ${g.days}d ago</span>`).join(' ')}</div></div>`;
        }
        $('#guest-modal-title').textContent = 'Playlist Detail';
        $('#guest-modal-content').innerHTML = html;
        $('#guest-modal').classList.remove('hidden');
        });
      }
      
      // Guest search
      // Search with clear buttons
      function setupSearchClear(inputId, clearId, onClear) {
        const input = $(inputId);
        const btn = $(clearId);
        if (!input || !btn) return;
        function syncBtn() { btn.classList.toggle('visible', input.value.length > 0); }
        input.addEventListener('input', syncBtn);
        btn.addEventListener('click', () => { input.value = ''; syncBtn(); if (onClear) onClear(); });
      }
      // Guests tab search
      $('#guest-search-filter').addEventListener('input', refreshGuests);
      setupSearchClear('#guest-search-filter', '#guest-filter-clear', refreshGuests);
      // Modal guest search
      $('#modal-guest-search').addEventListener('input', (e) => {
          const term = e.target.value.toLowerCase();
          $$("#modal-guest-list .guest-list-item").forEach(item => {
              item.style.display = item.dataset.guest.toLowerCase().includes(term) ? '' : 'none';
          });
      });
      setupSearchClear('#modal-guest-search', '#modal-guest-search-clear', () => {
        $$("#modal-guest-list .guest-list-item").forEach(i => i.style.display = '');
      });
      // History search
      $('#history-search').addEventListener('input', refreshHistory);
      setupSearchClear('#history-search', '#history-search-clear', refreshHistory);

      // Add Playlist form handlers
      $('#addPlaylistBtn').addEventListener('click', () => {
        const form = $('#addPlaylistForm');
        form.style.display = form.style.display === 'none' ? '' : 'none';
        if (form.style.display !== 'none') {
          $('#newPlaylistId').value = '';
          $('#addPlaylistError').style.display = 'none';
          $('#newPlaylistId').focus();
        }
      });
      $('#cancelAddPlaylist').addEventListener('click', () => {
        $('#addPlaylistForm').style.display = 'none';
      });
      $('#confirmAddPlaylist').addEventListener('click', async () => {
        const input = $('#newPlaylistId');
        const result = await addNewPlaylist(input.value);
        if (!result.ok) {
          const errEl = $('#addPlaylistError');
          errEl.textContent = result.error;
          errEl.style.display = '';
        } else {
          $('#addPlaylistForm').style.display = 'none';
        }
      });
      $('#newPlaylistId').addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          $('#confirmAddPlaylist').click();
        } else if (e.key === 'Escape') {
          $('#addPlaylistForm').style.display = 'none';
        }
      });

      // Sorting table headers
      $$('#history-table .sortable, #explorer thead .sortable').forEach(header => {
          header.addEventListener('click', () => {
              const sortKey = header.dataset.sort;
              const isExplorer = header.closest('#explorer');
              const sortState = isExplorer ? state.explorerSortOrder : state.sortOrder;

              if (sortState.column === sortKey) {
                  sortState.ascending = !sortState.ascending;
              } else {
                  sortState.column = sortKey;
                  sortState.ascending = false;
              }
              
              header.closest('table').querySelectorAll('.sortable').forEach(h => h.classList.remove('asc', 'desc'));
              header.classList.add(sortState.ascending ? 'asc' : 'desc');
              
              if (isExplorer) refreshExplorer(); else refreshHistory();
          });
      });

      // Sync All Finalized
      // Finalize All Drafts
      $('#syncAllBtn').addEventListener('click', async () => {
        if (!state.firebaseUser) {
          showToast('Please sign in first.', 'error');
          return;
        }
        const drafts = [];
        const weekStart = state.currentWeekStart;
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        state.weeklyPlan.forEach((cls, key) => {
          const clsDate = parseDateInput(cls.date);
          if (clsDate >= weekStart && clsDate <= weekEnd && cls.status === 'draft') {
            drafts.push({ key, cls });
          }
        });
        if (drafts.length === 0) {
          showToast('No drafts to finalize this week.', 'info');
          return;
        }
        setLoading($('#syncAllBtn'), true);
        try {
          const uid = state.firebaseUser.uid;
          let finalizedCount = 0;
          let skippedCount = 0;
          for (const { key, cls } of drafts) {
            if (!cls.playlist || cls.attendees.size === 0) {
              skippedCount++;
              continue;
            }
            const batch = db.batch();
            const classRef = db.collection('users').doc(uid).collection('classes').doc(safeDocId(key));
            batch.set(classRef, {
              date: cls.date, time: cls.time, playlist: cls.playlist,
              attendees: Array.from(cls.attendees), status: 'finalized',
              notes: cls.notes || '', classType: cls.classType || '', dateTimeKey: key
            });
            const recordsRef = db.collection('users').doc(uid).collection('records');
            for (const guest of cls.attendees) {
              const recordKey = buildRecordKey({ date: cls.date, time: normalizeTime(cls.time), guest, playlist: cls.playlist });
              batch.set(recordsRef.doc(safeDocId(recordKey)), {
                date: cls.date, time: normalizeTime(cls.time), guest, playlist: cls.playlist, classType: cls.classType || '', recordKey
              });
            }
            await batch.commit();
            finalizedCount++;
          }
          if (finalizedCount === 0) {
            showToast('No drafts were ready to finalize. Assign playlists and attendees first.', 'info');
          } else {
            const skippedMsg = skippedCount > 0 ? ` (${skippedCount} skipped)` : '';
            showToast(`Finalized ${finalizedCount} class${finalizedCount !== 1 ? 'es' : ''}!${skippedMsg}`, 'success');
          }
        } catch (error) {
          showToast('Finalize failed: ' + error.message, 'error');
        } finally {
          setLoading($('#syncAllBtn'), false);
        }
      });

      // Weekly Planner Navigation
      $('#prevWeekBtn').addEventListener('click', () => navigateWeek(-1));
      $('#currentWeekBtn').addEventListener('click', () => navigateWeek(0));
      $('#nextWeekBtn').addEventListener('click', () => navigateWeek(1));

      // Auth Buttons
      const signInHandler = async () => {
        const provider = new firebase.auth.GoogleAuthProvider();
        try {
          await auth.signInWithPopup(provider);
        } catch (err) {
          if (err.code === 'auth/popup-blocked' || err.code === 'auth/popup-closed-by-browser') {
            auth.signInWithRedirect(provider);
          } else {
            showToast('Sign in failed: ' + err.message, 'error');
          }
        }
      };
      $('#signInBtn').addEventListener('click', signInHandler);
      $('#settingsSignInBtn').addEventListener('click', signInHandler);
      $('#signOutBtn').addEventListener('click', () => auth.signOut());
      $('#settingsSignOutBtn').addEventListener('click', () => auth.signOut());

      // Settings Buttons
      $('#clearDataBtn').addEventListener('click', async () => {
          if (confirm('Are you sure you want to delete ALL data? This cannot be undone.')) {
              try {
                if (state.firebaseUser) await clearAllFirestoreData();
              } catch (e) {
                console.error('Firestore clear error:', e);
              }
              localStorage.removeItem('hiloPlaylistData');
              state.records = [];
              state.allGuests.clear();
              state.weeklyPlan.clear();
              state.playlistTags = new Map();
              state.playlistStatus = new Map();
              window.location.reload();
          }
      });
      $('#importCsvBtn').addEventListener('click', () => $('#fileInput').click());
      $('#exportCsvBtn').addEventListener('click', exportToCsv);
      $('#fileInput').addEventListener('change', handleCsvImport);

      // Modals
      $$('#close-class-modal, #cancel-modal').forEach(btn => btn.addEventListener('click', () => $('#class-modal').classList.add('hidden')));
      $('#close-guest-modal').addEventListener('click', () => $('#guest-modal').classList.add('hidden'));
      $('#save-draft-modal').addEventListener('click', handleModalSave);
      $('#finalize-modal').addEventListener('click', handleModalFinalize);
      $('#delete-class-modal').addEventListener('click', handleModalDelete);
      // Modal Select All / Clear All
      $('#modalSelectAllBtn').addEventListener('click', () => {
        const term = $('#modal-guest-search').value.toLowerCase();
        $$("#modal-guest-list .guest-list-item").forEach(item => {
          if (item.style.display !== 'none' && (!term || item.dataset.guest.toLowerCase().includes(term))) {
            state.modalAttendees.add(item.dataset.guest);
          }
        });
        renderModalSelectedGuests();
        updateModalGuestListSelection();
      });
      $('#modalClearAllBtn').addEventListener('click', () => {
        state.modalAttendees.clear();
        renderModalSelectedGuests();
        updateModalGuestListSelection();
      });
  }

  // --- Modal Handlers ---
  async function handleModalSave() {
      const cls = state.selectedClass;
      if (!cls) return;
      if (cls.status === 'finalized') {
          showToast('This class is finalized. Use Finalize to apply changes.', 'info');
          return;
      }
      if (state.modalAttendees.size === 0) {
          showToast('Please select at least one guest.', 'error');
          return;
      }
      const preservedPlaylist = normalizePlaylistId($('#modal-class-playlist').value || cls.playlist);

      const oldKey = createDateTimeKey(cls.date, cls.time);
      const newDate = ($('#modal-class-date').value || '').trim();
      const rawTime = ($('#modal-class-time').value || '').trim();
      if (!/^\d{4}-\d{2}-\d{2}$/.test(newDate)) {
          showToast('Please choose a valid class date.', 'error');
          return;
      }
      const newTime = normalizeTime(rawTime, '');
      if (!newTime) {
          showToast('Please choose a valid class time.', 'error');
          return;
      }
      const newKey = createDateTimeKey(newDate, newTime);
      const collision = state.weeklyPlan.get(newKey);
      if (oldKey !== newKey && collision && collision !== cls) {
          showToast('A class already exists at that date and time.', 'error');
          return;
      }

      const classData = {
        date: newDate,
        time: newTime,
        playlist: preservedPlaylist,
        attendees: new Set(state.modalAttendees),
        status: 'draft',
        notes: $('#modal-class-notes').value || '',
        classType: $('#modal-class-type').value || ''
      };
      if (state.selectedRecommendationClassKeys.has(oldKey)) {
        state.selectedRecommendationClassKeys.delete(oldKey);
        state.selectedRecommendationClassKeys.add(newKey);
      }

      if (state.firebaseUser) {
        const uid = state.firebaseUser.uid;
        if (oldKey !== newKey) {
          const batch = db.batch();
          batch.delete(db.collection('users').doc(uid).collection('classes').doc(safeDocId(oldKey)));
          batch.set(db.collection('users').doc(uid).collection('classes').doc(safeDocId(newKey)), {
            ...classData, attendees: Array.from(classData.attendees), dateTimeKey: newKey
          });
          await batch.commit();
        } else {
          await saveClassToFirestore(newKey, classData);
        }
      } else {
        if (oldKey !== newKey) state.weeklyPlan.delete(oldKey);
        state.weeklyPlan.set(newKey, classData);
        saveStateToLocalStorage();
        renderWeeklyCalendar();
      }
      refreshAll();
      showToast('Draft saved!', 'success');
      $('#class-modal').classList.add('hidden');
  }

  async function handleModalFinalize() {
      const cls = state.selectedClass;
      if (!cls || state.modalAttendees.size === 0) {
          showToast('Please select attendees.', 'error');
          return;
      }
      if (!state.firebaseUser) {
          showToast('Please sign in to finalize.', 'error');
          return;
      }
      setLoading($('#finalize-modal'), true);

      const oldKey = createDateTimeKey(cls.date, cls.time);
      const targetDate = ($('#modal-class-date').value || '').trim();
      const rawTargetTime = ($('#modal-class-time').value || '').trim();
      if (!/^\d{4}-\d{2}-\d{2}$/.test(targetDate)) {
          setLoading($('#finalize-modal'), false);
          showToast('Please choose a valid class date.', 'error');
          return;
      }
      const targetTime = normalizeTime(rawTargetTime, '');
      if (!targetTime) {
          setLoading($('#finalize-modal'), false);
          showToast('Please choose a valid class time.', 'error');
          return;
      }
      const newKey = createDateTimeKey(targetDate, targetTime);
      const collision = state.weeklyPlan.get(newKey);
      if (oldKey !== newKey && collision && collision !== cls) {
          setLoading($('#finalize-modal'), false);
          showToast('A class already exists at that date and time.', 'error');
          return;
      }

      try {
        const uid = state.firebaseUser.uid;
        const batch = db.batch();
        const classesRef = db.collection('users').doc(uid).collection('classes');
        const recordsRef = db.collection('users').doc(uid).collection('records');
        const latestClass = state.weeklyPlan.get(oldKey) || cls;
        const playlist = normalizePlaylistId($('#modal-class-playlist').value || latestClass.playlist || cls.playlist);
        if (!playlist) {
          showToast('Assign a playlist in Recommender before finalizing.', 'error');
          return;
        }
        const attendees = new Set(state.modalAttendees);
        const notes = $('#modal-class-notes').value || '';
        const classType = $('#modal-class-type').value || '';
        const wasFinalized = cls.status === 'finalized';
        if (state.selectedRecommendationClassKeys.has(oldKey)) {
          state.selectedRecommendationClassKeys.delete(oldKey);
          state.selectedRecommendationClassKeys.add(newKey);
        }

        // Delete old class doc if date/time changed
        if (oldKey !== newKey) {
          batch.delete(classesRef.doc(safeDocId(oldKey)));
        }
        // Remove old finalized attendance records that no longer match the edited class
        if (wasFinalized) {
          const oldPlaylist = normalizePlaylistId(cls.playlist);
          if (oldPlaylist) {
            const oldAttendees = cls.attendees instanceof Set ? cls.attendees : new Set(cls.attendees || []);
            const oldTime = normalizeTime(cls.time);
            oldAttendees.forEach(guest => {
              const oldRecordKey = buildRecordKey({
                date: cls.date,
                time: oldTime,
                guest,
                playlist: oldPlaylist
              });
              const stillPresent = attendees.has(guest) &&
                oldKey === newKey &&
                oldPlaylist === playlist &&
                oldTime === targetTime;
              if (!stillPresent) {
                batch.delete(recordsRef.doc(safeDocId(oldRecordKey)));
              }
            });
          }
        }
        // Write finalized class
        batch.set(classesRef.doc(safeDocId(newKey)), {
          date: targetDate, time: targetTime, playlist,
          attendees: Array.from(attendees), status: 'finalized',
          notes, classType, dateTimeKey: newKey
        });
        // Write attendance records
        for (const guest of attendees) {
          const recordKey = buildRecordKey({ date: targetDate, time: normalizeTime(targetTime), guest, playlist });
          batch.set(recordsRef.doc(safeDocId(recordKey)), {
            date: targetDate, time: normalizeTime(targetTime), guest, playlist, classType, recordKey
          });
        }
        await batch.commit();
        showToast(wasFinalized ? 'Finalized class updated!' : 'Class finalized!', 'success');
        refreshAll();
        renderWeeklyCalendar();
        $('#class-modal').classList.add('hidden');
      } catch (error) {
        showToast('Finalize failed: ' + error.message, 'error');
      } finally {
        setLoading($('#finalize-modal'), false);
      }
  }
  async function handleModalDelete() {
    const cls = state.selectedClass;
    if (!cls) return;
    if (confirm('Are you sure you want to delete this class?')) {
        const key = createDateTimeKey(cls.date, cls.time);
        state.selectedRecommendationClassKeys.delete(key);
        if (state.firebaseUser) {
          await deleteClassFromFirestore(key);
          // onSnapshot listener will update local state
        } else {
          state.weeklyPlan.delete(key);
          saveStateToLocalStorage();
          renderWeeklyCalendar();
        }
        refreshAll();
        showToast('Class deleted.', 'info');
        $('#class-modal').classList.add('hidden');
    }
  }
  // --- CSV Import/Export ---
  function exportToCsv() {
      if (state.records.length === 0) {
          showToast('No data to export.', 'info');
          return;
      }
      const headers = ['Date', 'Time', 'Guest', 'Playlist', 'Class Type', 'Class Number'];
      const csvRows = [headers.join(',')];
      state.records.forEach(r => {
          csvRows.push([r.date, r.time, `"${r.guest.replace(/"/g, '""')}"`, r.playlist, `"${(r.classType || '').replace(/"/g, '""')}"`, `"${(r.classNumber || '').replace(/"/g, '""')}"`].join(','));
      });
      const csvString = csvRows.join('\r\n');
      const blob = new Blob([csvString], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `hilo_playlist_export_${new Date().toISOString().slice(0,10)}.csv`;
      a.click();
      URL.revokeObjectURL(url);
      showToast('CSV export complete.', 'success');
  }

  function parseCsvRow(row) {
      const fields = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < row.length; i++) {
          const ch = row[i];
          if (inQuotes) {
              if (ch === '"' && row[i + 1] === '"') {
                  current += '"';
                  i++; // skip escaped quote
              } else if (ch === '"') {
                  inQuotes = false;
              } else {
                  current += ch;
              }
          } else {
              if (ch === '"') {
                  inQuotes = true;
              } else if (ch === ',') {
                  fields.push(current);
                  current = '';
              } else {
                  current += ch;
              }
          }
      }
      fields.push(current);
      return fields;
  }
  function parseCsvText(text) {
      const rows = [];
      let currentRow = [];
      let currentField = '';
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          if (inQuotes) {
              if (ch === '"' && text[i + 1] === '"') {
                  currentField += '"';
                  i++;
              } else if (ch === '"') {
                  inQuotes = false;
              } else {
                  currentField += ch;
              }
              continue;
          }
          if (ch === '"') {
              inQuotes = true;
          } else if (ch === ',') {
              currentRow.push(currentField);
              currentField = '';
          } else if (ch === '\n') {
              currentRow.push(currentField);
              currentField = '';
              if (currentRow.some(col => (col || '').trim().length > 0)) {
                  rows.push(currentRow);
              }
              currentRow = [];
          } else if (ch === '\r') {
              if (text[i + 1] !== '\n') {
                  currentRow.push(currentField);
                  currentField = '';
                  if (currentRow.some(col => (col || '').trim().length > 0)) {
                      rows.push(currentRow);
                  }
                  currentRow = [];
              }
          } else {
              currentField += ch;
          }
      }

      if (currentField.length > 0 || currentRow.length > 0) {
          currentRow.push(currentField);
          if (currentRow.some(col => (col || '').trim().length > 0)) {
              rows.push(currentRow);
          }
      }
      return rows;
  }
  function normalizeCsvHeader(header) {
      return (header || '').toString().trim().toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
  }
  function buildCsvHeaderLookup(headers) {
      const map = new Map();
      headers.forEach((header, index) => {
          const normalized = normalizeCsvHeader(header);
          if (normalized && !map.has(normalized)) map.set(normalized, index);
      });
      return map;
  }
  function getCsvValue(cols, headerLookup, aliases, fallbackIndex = -1) {
      for (const alias of aliases) {
          const idx = headerLookup.get(alias);
          if (idx !== undefined && idx < cols.length) return (cols[idx] || '').trim();
      }
      if (fallbackIndex >= 0 && fallbackIndex < cols.length) return (cols[fallbackIndex] || '').trim();
      return '';
  }
  function normalizeImportedDate(rawDate) {
      const parsed = parseDateInput((rawDate || '').toString().trim());
      return parsed ? formatDateKey(parsed) : '';
  }

  function handleCsvImport(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function(e) {
          const text = (e.target.result || '').toString();
          const rows = parseCsvText(text);
          if (rows.length === 0) {
              showToast('CSV appears empty.', 'error');
              return;
          }

          const headerCols = rows[0];
          const headerLookup = buildCsvHeaderLookup(headerCols);
          const knownHeaders = new Set([
            'date', 'time', 'guest', 'playlist',
            'date of class', 'class time', 'guest name', 'playlist number', 'class type',
            'class level', 'level', 'status', 'playlist status',
            'class number', 'class id', 'class', 'class no'
          ]);
          const hasKnownHeaders = headerCols.some(h => knownHeaders.has(normalizeCsvHeader(h)));
          const dataRows = hasKnownHeaders ? rows.slice(1) : rows;

          let importedCount = 0;
          const importedRecords = [];
          const taggedPlaylists = new Set();
          const statusPlaylists = new Set();
          dataRows.forEach(cols => {
              if (!Array.isArray(cols) || cols.every(col => !(col || '').trim())) return;
              const rawPlaylistValue = getCsvValue(cols, headerLookup, ['playlist', 'playlist number', 'playlist id'], 3);
              const parsedPlaylist = parseImportedPlaylist(rawPlaylistValue);
              const playlistId = parsedPlaylist.playlistId;
              const explicitStatus = normalizePlaylistStatus(getCsvValue(cols, headerLookup, ['status', 'playlist status']));
              const playlistStatus = explicitStatus || parsedPlaylist.inferredStatus;
              if (playlistId && playlistStatus) {
                if (state.playlistStatus.get(playlistId) !== playlistStatus) {
                  state.playlistStatus.set(playlistId, playlistStatus);
                }
                statusPlaylists.add(playlistId);
                ensurePlaylistInState(playlistId);
              }
              const date = normalizeImportedDate(getCsvValue(cols, headerLookup, ['date', 'date of class', 'class date'], 0));
              const time = normalizeTime(getCsvValue(cols, headerLookup, ['time', 'class time'], 1), '09:00');
              const guest = getCsvValue(cols, headerLookup, ['guest', 'guest name', 'name'], 2);
              const classType = getCsvValue(cols, headerLookup, ['class type', 'type', 'class level', 'level'], 4).replace(/\s+/g, ' ').trim();
              const classNumber = normalizeClassNumber(getCsvValue(cols, headerLookup, ['class number', 'class id', 'class no', 'class'], -1));
              const normalized = normalizeRecord({ date, time, guest, playlist: playlistId, classType, classNumber });
              if (!normalized) return;
              if (addRecordIfNew(normalized)) {
                  importedCount++;
                  importedRecords.push(normalized);
              }
              state.allGuests.add(normalized.guest);
              if (classType) {
                  const existingTags = state.playlistTags.get(normalized.playlist) || [];
                  if (!existingTags.includes(classType)) {
                    state.playlistTags.set(normalized.playlist, [...existingTags, classType]);
                    taggedPlaylists.add(normalized.playlist);
                  }
              }
          });
          rebuildPlaylistsFromData();
          saveStateToLocalStorage();
          updateRecordsPill();
          refreshAll();

          // Push to Firestore in chunked batches
          if (state.firebaseUser && (importedRecords.length > 0 || taggedPlaylists.size > 0 || statusPlaylists.size > 0)) {
            const uid = state.firebaseUser.uid;
            try {
              if (importedRecords.length > 0) {
                const recordsRef = db.collection('users').doc(uid).collection('records');
                const chunks = [];
                for (let i = 0; i < importedRecords.length; i += 500) {
                  chunks.push(importedRecords.slice(i, i + 500));
                }
                for (const chunk of chunks) {
                  const batch = db.batch();
                  chunk.forEach(r => {
                    const key = buildRecordKey(r);
                    batch.set(recordsRef.doc(safeDocId(key)), { ...r, recordKey: key });
                  });
                  await batch.commit();
                }
              }
              const playlistDocUpdates = new Set([...taggedPlaylists, ...statusPlaylists]);
              for (const playlistId of playlistDocUpdates) {
                const payload = {};
                if (taggedPlaylists.has(playlistId)) payload.classTypes = state.playlistTags.get(playlistId) || [];
                if (statusPlaylists.has(playlistId)) payload.status = state.playlistStatus.get(playlistId) || '';
                if (Object.keys(payload).length === 0) continue;
                await db.collection('users').doc(uid).collection('playlists').doc(playlistId).set(payload, { merge: true });
              }
              const details = [];
              if (taggedPlaylists.size > 0) details.push(`${taggedPlaylists.size} class-type tag set${taggedPlaylists.size !== 1 ? 's' : ''}`);
              if (statusPlaylists.size > 0) details.push(`${statusPlaylists.size} playlist status${statusPlaylists.size !== 1 ? 'es' : ''}`);
              const detailMsg = details.length > 0 ? ` and synced ${details.join(' and ')}` : '';
              showToast(`Imported ${importedCount} records${detailMsg} to Firebase`, 'success');
            } catch (err) {
              showToast(`Imported locally but Firebase sync failed: ${err.message}`, 'error');
            }
          } else {
            const details = [];
            if (taggedPlaylists.size > 0) details.push(`${taggedPlaylists.size} class-type tag set${taggedPlaylists.size !== 1 ? 's' : ''}`);
            if (statusPlaylists.size > 0) details.push(`${statusPlaylists.size} playlist status${statusPlaylists.size !== 1 ? 'es' : ''}`);
            const detailMsg = details.length > 0 ? ` and ${details.join(' and ')}` : '';
            showToast(`Imported ${importedCount} records${detailMsg}.`, 'success');
          }
      };
      reader.readAsText(file);
      $('#fileInput').value = ''; // Reset for next import
  }
  // --- Start the App ---
  document.addEventListener('DOMContentLoaded', initializeApp);
</script>
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').then(function(reg) {
      console.log('Service worker registered:', reg.scope);
    }).catch(function(err) {
      console.log('Service worker registration failed:', err);
    });
  }
</script>
</body>
</html>
